"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/lenis";
exports.ids = ["vendor-chunks/lenis"];
exports.modules = {

/***/ "(ssr)/./node_modules/lenis/dist/lenis-react.mjs":
/*!*************************************************!*\
  !*** ./node_modules/lenis/dist/lenis-react.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Lenis: () => (/* binding */ ReactLenis),\n/* harmony export */   LenisContext: () => (/* binding */ LenisContext),\n/* harmony export */   ReactLenis: () => (/* binding */ ReactLenis),\n/* harmony export */   \"default\": () => (/* binding */ ReactLenis),\n/* harmony export */   useLenis: () => (/* binding */ useLenis)\n/* harmony export */ });\n/* harmony import */ var lenis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lenis */ \"(ssr)/./node_modules/lenis/dist/lenis.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ Lenis,LenisContext,ReactLenis,default,useLenis auto */ // packages/react/src/provider.tsx\n\n\n// packages/react/src/store.ts\n\nvar Store = class {\n    constructor(state){\n        this.listeners = [];\n        this.state = state;\n    }\n    set(state) {\n        this.state = state;\n        for (let listener of this.listeners){\n            listener(this.state);\n        }\n    }\n    subscribe(listener) {\n        this.listeners = [\n            ...this.listeners,\n            listener\n        ];\n        return ()=>{\n            this.listeners = this.listeners.filter((l)=>l !== listener);\n        };\n    }\n    get() {\n        return this.state;\n    }\n};\nfunction useStore(store) {\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(store.get());\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return store.subscribe((state2)=>setState(state2));\n    }, [\n        store\n    ]);\n    return state;\n}\n// packages/react/src/provider.tsx\n\nvar LenisContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar rootLenisContextStore = new Store(null);\nvar ReactLenis = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ children, root = false, options = {}, autoRaf = true, ...props }, ref)=>{\n    const wrapperRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const contentRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [lenis, setLenis] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>({\n            wrapper: wrapperRef.current,\n            content: contentRef.current,\n            lenis\n        }), [\n        lenis\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const lenis2 = new lenis__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n            ...options,\n            ...wrapperRef.current && contentRef.current && {\n                wrapper: wrapperRef.current,\n                content: contentRef.current\n            },\n            autoRaf: options?.autoRaf ?? autoRaf\n        });\n        setLenis(lenis2);\n        return ()=>{\n            lenis2.destroy();\n            setLenis(void 0);\n        };\n    }, [\n        root,\n        JSON.stringify({\n            ...options,\n            wrapper: null,\n            content: null\n        })\n    ]);\n    const callbacksRefs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const addCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((callback, priority)=>{\n        callbacksRefs.current.push({\n            callback,\n            priority\n        });\n        callbacksRefs.current.sort((a, b)=>a.priority - b.priority);\n    }, []);\n    const removeCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((callback)=>{\n        callbacksRefs.current = callbacksRefs.current.filter((cb)=>cb.callback !== callback);\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (root && lenis) {\n            rootLenisContextStore.set({\n                lenis,\n                addCallback,\n                removeCallback\n            });\n            return ()=>rootLenisContextStore.set(null);\n        }\n    }, [\n        root,\n        lenis,\n        addCallback,\n        removeCallback\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!lenis) return;\n        const onScroll = (data)=>{\n            for(let i = 0; i < callbacksRefs.current.length; i++){\n                callbacksRefs.current[i]?.callback(data);\n            }\n        };\n        lenis.on(\"scroll\", onScroll);\n        return ()=>{\n            lenis.off(\"scroll\", onScroll);\n        };\n    }, [\n        lenis\n    ]);\n    if (!children) return null;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(LenisContext.Provider, {\n        value: {\n            lenis,\n            addCallback,\n            removeCallback\n        },\n        children: root && root !== \"asChild\" ? children : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n            ref: wrapperRef,\n            ...props,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n                ref: contentRef,\n                children\n            })\n        })\n    });\n});\n// packages/react/src/use-lenis.ts\n\nvar fallbackContext = {};\nfunction useLenis(callback, deps = [], priority = 0) {\n    const localContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LenisContext);\n    const rootContext = useStore(rootLenisContextStore);\n    const currentContext = localContext ?? rootContext ?? fallbackContext;\n    const { lenis, addCallback, removeCallback } = currentContext;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!callback || !addCallback || !removeCallback || !lenis) return;\n        addCallback(callback, priority);\n        callback(lenis);\n        return ()=>{\n            removeCallback(callback);\n        };\n    }, [\n        lenis,\n        addCallback,\n        removeCallback,\n        priority,\n        ...deps\n    ]);\n    return lenis;\n}\n //# sourceMappingURL=lenis-react.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGVuaXMvZGlzdC9sZW5pcy1yZWFjdC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7b0dBRUEsa0NBQWtDO0FBQ1I7QUFTWDtBQUVmLDhCQUE4QjtBQUNjO0FBQzVDLElBQUlVLFFBQVE7SUFDVkMsWUFBWUMsS0FBSyxDQUFFO2FBR25CQyxZQUFZLEVBQUU7UUFGWixJQUFJLENBQUNELEtBQUssR0FBR0E7SUFDZjtJQUVBRSxJQUFJRixLQUFLLEVBQUU7UUFDVCxJQUFJLENBQUNBLEtBQUssR0FBR0E7UUFDYixLQUFLLElBQUlHLFlBQVksSUFBSSxDQUFDRixTQUFTLENBQUU7WUFDbkNFLFNBQVMsSUFBSSxDQUFDSCxLQUFLO1FBQ3JCO0lBQ0Y7SUFDQUksVUFBVUQsUUFBUSxFQUFFO1FBQ2xCLElBQUksQ0FBQ0YsU0FBUyxHQUFHO2VBQUksSUFBSSxDQUFDQSxTQUFTO1lBQUVFO1NBQVM7UUFDOUMsT0FBTztZQUNMLElBQUksQ0FBQ0YsU0FBUyxHQUFHLElBQUksQ0FBQ0EsU0FBUyxDQUFDSSxNQUFNLENBQUMsQ0FBQ0MsSUFBTUEsTUFBTUg7UUFDdEQ7SUFDRjtJQUNBSSxNQUFNO1FBQ0osT0FBTyxJQUFJLENBQUNQLEtBQUs7SUFDbkI7QUFDRjtBQUNBLFNBQVNRLFNBQVNDLEtBQUs7SUFDckIsTUFBTSxDQUFDVCxPQUFPVSxTQUFTLEdBQUdkLCtDQUFRQSxDQUFDYSxNQUFNRixHQUFHO0lBQzVDZixnREFBU0EsQ0FBQztRQUNSLE9BQU9pQixNQUFNTCxTQUFTLENBQUMsQ0FBQ08sU0FBV0QsU0FBU0M7SUFDOUMsR0FBRztRQUFDRjtLQUFNO0lBQ1YsT0FBT1Q7QUFDVDtBQUVBLGtDQUFrQztBQUNNO0FBQ3hDLElBQUlhLDZCQUFleEIsb0RBQWFBLENBQUM7QUFDakMsSUFBSXlCLHdCQUF3QixJQUFJaEIsTUFBTTtBQUN0QyxJQUFJaUIsMkJBQWF6QixpREFBVUEsQ0FDekIsQ0FBQyxFQUNDMEIsUUFBUSxFQUNSQyxP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Q0FBQztBQUN2QixTQUFTQyxTQUFTbkIsUUFBUSxFQUFFb0IsT0FBTyxFQUFFLEVBQUVuQixXQUFXLENBQUM7SUFDakQsTUFBTW9CLGVBQWVMLGlEQUFVQSxDQUFDdEM7SUFDaEMsTUFBTTRDLGNBQWNqRCxTQUFTTTtJQUM3QixNQUFNNEMsaUJBQWlCRixnQkFBZ0JDLGVBQWVKO0lBQ3RELE1BQU0sRUFBRTdCLEtBQUssRUFBRVUsV0FBVyxFQUFFTyxjQUFjLEVBQUUsR0FBR2lCO0lBQy9DTixnREFBVUEsQ0FBQztRQUNULElBQUksQ0FBQ2pCLFlBQVksQ0FBQ0QsZUFBZSxDQUFDTyxrQkFBa0IsQ0FBQ2pCLE9BQU87UUFDNURVLFlBQVlDLFVBQVVDO1FBQ3RCRCxTQUFTWDtRQUNULE9BQU87WUFDTGlCLGVBQWVOO1FBQ2pCO0lBQ0YsR0FBRztRQUFDWDtRQUFPVTtRQUFhTztRQUFnQkw7V0FBYW1CO0tBQUs7SUFDMUQsT0FBTy9CO0FBQ1Q7QUFPRSxDQUNGLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL3R0Yy13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2xlbmlzL2Rpc3QvbGVuaXMtcmVhY3QubWpzP2Y1MWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbi8vIHBhY2thZ2VzL3JlYWN0L3NyYy9wcm92aWRlci50c3hcbmltcG9ydCBMZW5pcyBmcm9tIFwibGVuaXNcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZUNvbnRleHQsXG4gIGZvcndhcmRSZWYsXG4gIHVzZUNhbGxiYWNrLFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MixcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSxcbiAgdXNlUmVmLFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTJcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHBhY2thZ2VzL3JlYWN0L3NyYy9zdG9yZS50c1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xudmFyIFN0b3JlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzdGF0ZSkge1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgfVxuICBsaXN0ZW5lcnMgPSBbXTtcbiAgc2V0KHN0YXRlKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKSB7XG4gICAgICBsaXN0ZW5lcih0aGlzLnN0YXRlKTtcbiAgICB9XG4gIH1cbiAgc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBbLi4udGhpcy5saXN0ZW5lcnMsIGxpc3RlbmVyXTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhpcy5saXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycy5maWx0ZXIoKGwpID0+IGwgIT09IGxpc3RlbmVyKTtcbiAgICB9O1xuICB9XG4gIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgfVxufTtcbmZ1bmN0aW9uIHVzZVN0b3JlKHN0b3JlKSB7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGUoc3RvcmUuZ2V0KCkpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBzdG9yZS5zdWJzY3JpYmUoKHN0YXRlMikgPT4gc2V0U3RhdGUoc3RhdGUyKSk7XG4gIH0sIFtzdG9yZV0pO1xuICByZXR1cm4gc3RhdGU7XG59XG5cbi8vIHBhY2thZ2VzL3JlYWN0L3NyYy9wcm92aWRlci50c3hcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIExlbmlzQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG52YXIgcm9vdExlbmlzQ29udGV4dFN0b3JlID0gbmV3IFN0b3JlKG51bGwpO1xudmFyIFJlYWN0TGVuaXMgPSBmb3J3YXJkUmVmKFxuICAoe1xuICAgIGNoaWxkcmVuLFxuICAgIHJvb3QgPSBmYWxzZSxcbiAgICBvcHRpb25zID0ge30sXG4gICAgYXV0b1JhZiA9IHRydWUsXG4gICAgLi4ucHJvcHNcbiAgfSwgcmVmKSA9PiB7XG4gICAgY29uc3Qgd3JhcHBlclJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBjb250ZW50UmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IFtsZW5pcywgc2V0TGVuaXNdID0gdXNlU3RhdGUyKHZvaWQgMCk7XG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShcbiAgICAgIHJlZixcbiAgICAgICgpID0+ICh7XG4gICAgICAgIHdyYXBwZXI6IHdyYXBwZXJSZWYuY3VycmVudCxcbiAgICAgICAgY29udGVudDogY29udGVudFJlZi5jdXJyZW50LFxuICAgICAgICBsZW5pc1xuICAgICAgfSksXG4gICAgICBbbGVuaXNdXG4gICAgKTtcbiAgICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICAgIGNvbnN0IGxlbmlzMiA9IG5ldyBMZW5pcyh7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIC4uLndyYXBwZXJSZWYuY3VycmVudCAmJiBjb250ZW50UmVmLmN1cnJlbnQgJiYge1xuICAgICAgICAgIHdyYXBwZXI6IHdyYXBwZXJSZWYuY3VycmVudCxcbiAgICAgICAgICBjb250ZW50OiBjb250ZW50UmVmLmN1cnJlbnRcbiAgICAgICAgfSxcbiAgICAgICAgYXV0b1JhZjogb3B0aW9ucz8uYXV0b1JhZiA/PyBhdXRvUmFmXG4gICAgICAgIC8vIHRoaXMgaXMgdG8gYXZvaWQgYnJlYWtpbmcgdGhlIGF1dG9SYWYgcHJvcCBpZiBpdCdzIHN0aWxsIHVzZWQgKHJlcXVpcmUgYnJlYWtpbmcgY2hhbmdlKVxuICAgICAgfSk7XG4gICAgICBzZXRMZW5pcyhsZW5pczIpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgbGVuaXMyLmRlc3Ryb3koKTtcbiAgICAgICAgc2V0TGVuaXModm9pZCAwKTtcbiAgICAgIH07XG4gICAgfSwgW3Jvb3QsIEpTT04uc3RyaW5naWZ5KHsgLi4ub3B0aW9ucywgd3JhcHBlcjogbnVsbCwgY29udGVudDogbnVsbCB9KV0pO1xuICAgIGNvbnN0IGNhbGxiYWNrc1JlZnMgPSB1c2VSZWYoW10pO1xuICAgIGNvbnN0IGFkZENhbGxiYWNrID0gdXNlQ2FsbGJhY2soXG4gICAgICAoY2FsbGJhY2ssIHByaW9yaXR5KSA9PiB7XG4gICAgICAgIGNhbGxiYWNrc1JlZnMuY3VycmVudC5wdXNoKHsgY2FsbGJhY2ssIHByaW9yaXR5IH0pO1xuICAgICAgICBjYWxsYmFja3NSZWZzLmN1cnJlbnQuc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xuICAgICAgfSxcbiAgICAgIFtdXG4gICAgKTtcbiAgICBjb25zdCByZW1vdmVDYWxsYmFjayA9IHVzZUNhbGxiYWNrKFxuICAgICAgKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrc1JlZnMuY3VycmVudCA9IGNhbGxiYWNrc1JlZnMuY3VycmVudC5maWx0ZXIoXG4gICAgICAgICAgKGNiKSA9PiBjYi5jYWxsYmFjayAhPT0gY2FsbGJhY2tcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBbXVxuICAgICk7XG4gICAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgICBpZiAocm9vdCAmJiBsZW5pcykge1xuICAgICAgICByb290TGVuaXNDb250ZXh0U3RvcmUuc2V0KHsgbGVuaXMsIGFkZENhbGxiYWNrLCByZW1vdmVDYWxsYmFjayB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHJvb3RMZW5pc0NvbnRleHRTdG9yZS5zZXQobnVsbCk7XG4gICAgICB9XG4gICAgfSwgW3Jvb3QsIGxlbmlzLCBhZGRDYWxsYmFjaywgcmVtb3ZlQ2FsbGJhY2tdKTtcbiAgICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICAgIGlmICghbGVuaXMpIHJldHVybjtcbiAgICAgIGNvbnN0IG9uU2Nyb2xsID0gKGRhdGEpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWxsYmFja3NSZWZzLmN1cnJlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjYWxsYmFja3NSZWZzLmN1cnJlbnRbaV0/LmNhbGxiYWNrKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbGVuaXMub24oXCJzY3JvbGxcIiwgb25TY3JvbGwpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgbGVuaXMub2ZmKFwic2Nyb2xsXCIsIG9uU2Nyb2xsKTtcbiAgICAgIH07XG4gICAgfSwgW2xlbmlzXSk7XG4gICAgaWYgKCFjaGlsZHJlbikgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICBMZW5pc0NvbnRleHQuUHJvdmlkZXIsXG4gICAgICB7XG4gICAgICAgIHZhbHVlOiB7IGxlbmlzLCBhZGRDYWxsYmFjaywgcmVtb3ZlQ2FsbGJhY2sgfSxcbiAgICAgICAgY2hpbGRyZW46IHJvb3QgJiYgcm9vdCAhPT0gXCJhc0NoaWxkXCIgPyBjaGlsZHJlbiA6IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyByZWY6IHdyYXBwZXJSZWYsIC4uLnByb3BzLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcImRpdlwiLCB7IHJlZjogY29udGVudFJlZiwgY2hpbGRyZW4gfSkgfSlcbiAgICAgIH1cbiAgICApO1xuICB9XG4pO1xuXG4vLyBwYWNrYWdlcy9yZWFjdC9zcmMvdXNlLWxlbmlzLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MyB9IGZyb20gXCJyZWFjdFwiO1xudmFyIGZhbGxiYWNrQ29udGV4dCA9IHt9O1xuZnVuY3Rpb24gdXNlTGVuaXMoY2FsbGJhY2ssIGRlcHMgPSBbXSwgcHJpb3JpdHkgPSAwKSB7XG4gIGNvbnN0IGxvY2FsQ29udGV4dCA9IHVzZUNvbnRleHQoTGVuaXNDb250ZXh0KTtcbiAgY29uc3Qgcm9vdENvbnRleHQgPSB1c2VTdG9yZShyb290TGVuaXNDb250ZXh0U3RvcmUpO1xuICBjb25zdCBjdXJyZW50Q29udGV4dCA9IGxvY2FsQ29udGV4dCA/PyByb290Q29udGV4dCA/PyBmYWxsYmFja0NvbnRleHQ7XG4gIGNvbnN0IHsgbGVuaXMsIGFkZENhbGxiYWNrLCByZW1vdmVDYWxsYmFjayB9ID0gY3VycmVudENvbnRleHQ7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIGlmICghY2FsbGJhY2sgfHwgIWFkZENhbGxiYWNrIHx8ICFyZW1vdmVDYWxsYmFjayB8fCAhbGVuaXMpIHJldHVybjtcbiAgICBhZGRDYWxsYmFjayhjYWxsYmFjaywgcHJpb3JpdHkpO1xuICAgIGNhbGxiYWNrKGxlbmlzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmVtb3ZlQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgIH07XG4gIH0sIFtsZW5pcywgYWRkQ2FsbGJhY2ssIHJlbW92ZUNhbGxiYWNrLCBwcmlvcml0eSwgLi4uZGVwc10pO1xuICByZXR1cm4gbGVuaXM7XG59XG5leHBvcnQge1xuICBSZWFjdExlbmlzIGFzIExlbmlzLFxuICBMZW5pc0NvbnRleHQsXG4gIFJlYWN0TGVuaXMsXG4gIFJlYWN0TGVuaXMgYXMgZGVmYXVsdCxcbiAgdXNlTGVuaXNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZW5pcy1yZWFjdC5tanMubWFwIl0sIm5hbWVzIjpbIkxlbmlzIiwiY3JlYXRlQ29udGV4dCIsImZvcndhcmRSZWYiLCJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInVzZUVmZmVjdDIiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VTdGF0ZTIiLCJTdG9yZSIsImNvbnN0cnVjdG9yIiwic3RhdGUiLCJsaXN0ZW5lcnMiLCJzZXQiLCJsaXN0ZW5lciIsInN1YnNjcmliZSIsImZpbHRlciIsImwiLCJnZXQiLCJ1c2VTdG9yZSIsInN0b3JlIiwic2V0U3RhdGUiLCJzdGF0ZTIiLCJqc3giLCJMZW5pc0NvbnRleHQiLCJyb290TGVuaXNDb250ZXh0U3RvcmUiLCJSZWFjdExlbmlzIiwiY2hpbGRyZW4iLCJyb290Iiwib3B0aW9ucyIsImF1dG9SYWYiLCJwcm9wcyIsInJlZiIsIndyYXBwZXJSZWYiLCJjb250ZW50UmVmIiwibGVuaXMiLCJzZXRMZW5pcyIsIndyYXBwZXIiLCJjdXJyZW50IiwiY29udGVudCIsImxlbmlzMiIsImRlc3Ryb3kiLCJKU09OIiwic3RyaW5naWZ5IiwiY2FsbGJhY2tzUmVmcyIsImFkZENhbGxiYWNrIiwiY2FsbGJhY2siLCJwcmlvcml0eSIsInB1c2giLCJzb3J0IiwiYSIsImIiLCJyZW1vdmVDYWxsYmFjayIsImNiIiwib25TY3JvbGwiLCJkYXRhIiwiaSIsImxlbmd0aCIsIm9uIiwib2ZmIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZUNvbnRleHQiLCJ1c2VFZmZlY3QzIiwiZmFsbGJhY2tDb250ZXh0IiwidXNlTGVuaXMiLCJkZXBzIiwibG9jYWxDb250ZXh0Iiwicm9vdENvbnRleHQiLCJjdXJyZW50Q29udGV4dCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/lenis/dist/lenis-react.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/lenis/dist/lenis.mjs":
/*!*******************************************!*\
  !*** ./node_modules/lenis/dist/lenis.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Lenis)\n/* harmony export */ });\n// package.json\nvar version = \"1.3.17\";\n// packages/core/src/maths.ts\nfunction clamp(min, input, max) {\n    return Math.max(min, Math.min(input, max));\n}\nfunction lerp(x, y, t) {\n    return (1 - t) * x + t * y;\n}\nfunction damp(x, y, lambda, deltaTime) {\n    return lerp(x, y, 1 - Math.exp(-lambda * deltaTime));\n}\nfunction modulo(n, d) {\n    return (n % d + d) % d;\n}\n// packages/core/src/animate.ts\nvar Animate = class {\n    /**\n   * Advance the animation by the given delta time\n   *\n   * @param deltaTime - The time in seconds to advance the animation\n   */ advance(deltaTime) {\n        if (!this.isRunning) return;\n        let completed = false;\n        if (this.duration && this.easing) {\n            this.currentTime += deltaTime;\n            const linearProgress = clamp(0, this.currentTime / this.duration, 1);\n            completed = linearProgress >= 1;\n            const easedProgress = completed ? 1 : this.easing(linearProgress);\n            this.value = this.from + (this.to - this.from) * easedProgress;\n        } else if (this.lerp) {\n            this.value = damp(this.value, this.to, this.lerp * 60, deltaTime);\n            if (Math.round(this.value) === this.to) {\n                this.value = this.to;\n                completed = true;\n            }\n        } else {\n            this.value = this.to;\n            completed = true;\n        }\n        if (completed) {\n            this.stop();\n        }\n        this.onUpdate?.(this.value, completed);\n    }\n    /** Stop the animation */ stop() {\n        this.isRunning = false;\n    }\n    /**\n   * Set up the animation from a starting value to an ending value\n   * with optional parameters for lerping, duration, easing, and onUpdate callback\n   *\n   * @param from - The starting value\n   * @param to - The ending value\n   * @param options - Options for the animation\n   */ fromTo(from, to, { lerp: lerp2, duration, easing, onStart, onUpdate }) {\n        this.from = this.value = from;\n        this.to = to;\n        this.lerp = lerp2;\n        this.duration = duration;\n        this.easing = easing;\n        this.currentTime = 0;\n        this.isRunning = true;\n        onStart?.();\n        this.onUpdate = onUpdate;\n    }\n    constructor(){\n        this.isRunning = false;\n        this.value = 0;\n        this.from = 0;\n        this.to = 0;\n        this.currentTime = 0;\n    }\n};\n// packages/core/src/debounce.ts\nfunction debounce(callback, delay) {\n    let timer;\n    return function(...args) {\n        let context = this;\n        clearTimeout(timer);\n        timer = setTimeout(()=>{\n            timer = void 0;\n            callback.apply(context, args);\n        }, delay);\n    };\n}\n// packages/core/src/dimensions.ts\nvar Dimensions = class {\n    constructor(wrapper, content, { autoResize = true, debounce: debounceValue = 250 } = {}){\n        this.width = 0;\n        this.height = 0;\n        this.scrollHeight = 0;\n        this.scrollWidth = 0;\n        this.resize = ()=>{\n            this.onWrapperResize();\n            this.onContentResize();\n        };\n        this.onWrapperResize = ()=>{\n            if (this.wrapper instanceof Window) {\n                this.width = window.innerWidth;\n                this.height = window.innerHeight;\n            } else {\n                this.width = this.wrapper.clientWidth;\n                this.height = this.wrapper.clientHeight;\n            }\n        };\n        this.onContentResize = ()=>{\n            if (this.wrapper instanceof Window) {\n                this.scrollHeight = this.content.scrollHeight;\n                this.scrollWidth = this.content.scrollWidth;\n            } else {\n                this.scrollHeight = this.wrapper.scrollHeight;\n                this.scrollWidth = this.wrapper.scrollWidth;\n            }\n        };\n        this.wrapper = wrapper;\n        this.content = content;\n        if (autoResize) {\n            this.debouncedResize = debounce(this.resize, debounceValue);\n            if (this.wrapper instanceof Window) {\n                window.addEventListener(\"resize\", this.debouncedResize, false);\n            } else {\n                this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize);\n                this.wrapperResizeObserver.observe(this.wrapper);\n            }\n            this.contentResizeObserver = new ResizeObserver(this.debouncedResize);\n            this.contentResizeObserver.observe(this.content);\n        }\n        this.resize();\n    }\n    destroy() {\n        this.wrapperResizeObserver?.disconnect();\n        this.contentResizeObserver?.disconnect();\n        if (this.wrapper === window && this.debouncedResize) {\n            window.removeEventListener(\"resize\", this.debouncedResize, false);\n        }\n    }\n    get limit() {\n        return {\n            x: this.scrollWidth - this.width,\n            y: this.scrollHeight - this.height\n        };\n    }\n};\n// packages/core/src/emitter.ts\nvar Emitter = class {\n    /**\n   * Emit an event with the given data\n   * @param event Event name\n   * @param args Data to pass to the event handlers\n   */ emit(event, ...args) {\n        let callbacks = this.events[event] || [];\n        for(let i = 0, length = callbacks.length; i < length; i++){\n            callbacks[i]?.(...args);\n        }\n    }\n    /**\n   * Add a callback to the event\n   * @param event Event name\n   * @param cb Callback function\n   * @returns Unsubscribe function\n   */ on(event, cb) {\n        this.events[event]?.push(cb) || (this.events[event] = [\n            cb\n        ]);\n        return ()=>{\n            this.events[event] = this.events[event]?.filter((i)=>cb !== i);\n        };\n    }\n    /**\n   * Remove a callback from the event\n   * @param event Event name\n   * @param callback Callback function\n   */ off(event, callback) {\n        this.events[event] = this.events[event]?.filter((i)=>callback !== i);\n    }\n    /**\n   * Remove all event listeners and clean up\n   */ destroy() {\n        this.events = {};\n    }\n    constructor(){\n        this.events = {};\n    }\n};\n// packages/core/src/virtual-scroll.ts\nvar LINE_HEIGHT = 100 / 6;\nvar listenerOptions = {\n    passive: false\n};\nvar VirtualScroll = class {\n    constructor(element, options = {\n        wheelMultiplier: 1,\n        touchMultiplier: 1\n    }){\n        this.touchStart = {\n            x: 0,\n            y: 0\n        };\n        this.lastDelta = {\n            x: 0,\n            y: 0\n        };\n        this.window = {\n            width: 0,\n            height: 0\n        };\n        this.emitter = new Emitter();\n        /**\n   * Event handler for 'touchstart' event\n   *\n   * @param event Touch event\n   */ this.onTouchStart = (event)=>{\n            const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;\n            this.touchStart.x = clientX;\n            this.touchStart.y = clientY;\n            this.lastDelta = {\n                x: 0,\n                y: 0\n            };\n            this.emitter.emit(\"scroll\", {\n                deltaX: 0,\n                deltaY: 0,\n                event\n            });\n        };\n        /** Event handler for 'touchmove' event */ this.onTouchMove = (event)=>{\n            const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;\n            const deltaX = -(clientX - this.touchStart.x) * this.options.touchMultiplier;\n            const deltaY = -(clientY - this.touchStart.y) * this.options.touchMultiplier;\n            this.touchStart.x = clientX;\n            this.touchStart.y = clientY;\n            this.lastDelta = {\n                x: deltaX,\n                y: deltaY\n            };\n            this.emitter.emit(\"scroll\", {\n                deltaX,\n                deltaY,\n                event\n            });\n        };\n        this.onTouchEnd = (event)=>{\n            this.emitter.emit(\"scroll\", {\n                deltaX: this.lastDelta.x,\n                deltaY: this.lastDelta.y,\n                event\n            });\n        };\n        /** Event handler for 'wheel' event */ this.onWheel = (event)=>{\n            let { deltaX, deltaY, deltaMode } = event;\n            const multiplierX = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.width : 1;\n            const multiplierY = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.height : 1;\n            deltaX *= multiplierX;\n            deltaY *= multiplierY;\n            deltaX *= this.options.wheelMultiplier;\n            deltaY *= this.options.wheelMultiplier;\n            this.emitter.emit(\"scroll\", {\n                deltaX,\n                deltaY,\n                event\n            });\n        };\n        this.onWindowResize = ()=>{\n            this.window = {\n                width: window.innerWidth,\n                height: window.innerHeight\n            };\n        };\n        this.element = element;\n        this.options = options;\n        window.addEventListener(\"resize\", this.onWindowResize, false);\n        this.onWindowResize();\n        this.element.addEventListener(\"wheel\", this.onWheel, listenerOptions);\n        this.element.addEventListener(\"touchstart\", this.onTouchStart, listenerOptions);\n        this.element.addEventListener(\"touchmove\", this.onTouchMove, listenerOptions);\n        this.element.addEventListener(\"touchend\", this.onTouchEnd, listenerOptions);\n    }\n    /**\n   * Add an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   */ on(event, callback) {\n        return this.emitter.on(event, callback);\n    }\n    /** Remove all event listeners and clean up */ destroy() {\n        this.emitter.destroy();\n        window.removeEventListener(\"resize\", this.onWindowResize, false);\n        this.element.removeEventListener(\"wheel\", this.onWheel, listenerOptions);\n        this.element.removeEventListener(\"touchstart\", this.onTouchStart, listenerOptions);\n        this.element.removeEventListener(\"touchmove\", this.onTouchMove, listenerOptions);\n        this.element.removeEventListener(\"touchend\", this.onTouchEnd, listenerOptions);\n    }\n};\n// packages/core/src/lenis.ts\nvar defaultEasing = (t)=>Math.min(1, 1.001 - Math.pow(2, -10 * t));\nvar Lenis = class {\n    constructor({ wrapper = window, content = document.documentElement, eventsTarget = wrapper, smoothWheel = true, syncTouch = false, syncTouchLerp = 0.075, touchInertiaExponent = 1.7, duration, // in seconds\n    easing, lerp: lerp2 = 0.1, infinite = false, orientation = \"vertical\", // vertical, horizontal\n    gestureOrientation = orientation === \"horizontal\" ? \"both\" : \"vertical\", // vertical, horizontal, both\n    touchMultiplier = 1, wheelMultiplier = 1, autoResize = true, prevent, virtualScroll, overscroll = true, autoRaf = false, anchors = false, autoToggle = false, // https://caniuse.com/?search=transition-behavior\n    allowNestedScroll = false, // @ts-ignore: this will be deprecated in the future\n    __experimental__naiveDimensions = false, naiveDimensions = __experimental__naiveDimensions, stopInertiaOnNavigate = false } = {}){\n        this._isScrolling = false;\n        // true when scroll is animating\n        this._isStopped = false;\n        // true if user should not be able to scroll - enable/disable programmatically\n        this._isLocked = false;\n        // same as isStopped but enabled/disabled when scroll reaches target\n        this._preventNextNativeScrollEvent = false;\n        this._resetVelocityTimeout = null;\n        this._rafId = null;\n        /**\n   * The time in ms since the lenis instance was created\n   */ this.time = 0;\n        /**\n   * User data that will be forwarded through the scroll event\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   userData: {\n   *     foo: 'bar'\n   *   }\n   * })\n   */ this.userData = {};\n        /**\n   * The last velocity of the scroll\n   */ this.lastVelocity = 0;\n        /**\n   * The current velocity of the scroll\n   */ this.velocity = 0;\n        /**\n   * The direction of the scroll\n   */ this.direction = 0;\n        // These are instanciated here as they don't need information from the options\n        this.animate = new Animate();\n        this.emitter = new Emitter();\n        this.onScrollEnd = (e)=>{\n            if (!(e instanceof CustomEvent)) {\n                if (this.isScrolling === \"smooth\" || this.isScrolling === false) {\n                    e.stopPropagation();\n                }\n            }\n        };\n        this.dispatchScrollendEvent = ()=>{\n            this.options.wrapper.dispatchEvent(new CustomEvent(\"scrollend\", {\n                bubbles: this.options.wrapper === window,\n                // cancelable: false,\n                detail: {\n                    lenisScrollEnd: true\n                }\n            }));\n        };\n        this.onTransitionEnd = (event)=>{\n            if (event.propertyName.includes(\"overflow\")) {\n                this.checkOverflow();\n            }\n        };\n        this.onClick = (event)=>{\n            const path = event.composedPath();\n            const anchorElements = path.filter((node)=>node instanceof HTMLAnchorElement && node.getAttribute(\"href\"));\n            if (this.options.anchors) {\n                const anchor = anchorElements.find((node)=>node.getAttribute(\"href\")?.includes(\"#\"));\n                if (anchor) {\n                    const href = anchor.getAttribute(\"href\");\n                    if (href) {\n                        const options = typeof this.options.anchors === \"object\" && this.options.anchors ? this.options.anchors : void 0;\n                        const target = `#${href.split(\"#\")[1]}`;\n                        this.scrollTo(target, options);\n                    }\n                }\n            }\n            if (this.options.stopInertiaOnNavigate) {\n                const internalLink = anchorElements.find((node)=>node.host === window.location.host);\n                if (internalLink) {\n                    this.reset();\n                }\n            }\n        };\n        this.onPointerDown = (event)=>{\n            if (event.button === 1) {\n                this.reset();\n            }\n        };\n        this.onVirtualScroll = (data)=>{\n            if (typeof this.options.virtualScroll === \"function\" && this.options.virtualScroll(data) === false) return;\n            const { deltaX, deltaY, event } = data;\n            this.emitter.emit(\"virtual-scroll\", {\n                deltaX,\n                deltaY,\n                event\n            });\n            if (event.ctrlKey) return;\n            if (event.lenisStopPropagation) return;\n            const isTouch = event.type.includes(\"touch\");\n            const isWheel = event.type.includes(\"wheel\");\n            this.isTouching = event.type === \"touchstart\" || event.type === \"touchmove\";\n            const isClickOrTap = deltaX === 0 && deltaY === 0;\n            const isTapToStop = this.options.syncTouch && isTouch && event.type === \"touchstart\" && isClickOrTap && !this.isStopped && !this.isLocked;\n            if (isTapToStop) {\n                this.reset();\n                return;\n            }\n            const isUnknownGesture = this.options.gestureOrientation === \"vertical\" && deltaY === 0 || this.options.gestureOrientation === \"horizontal\" && deltaX === 0;\n            if (isClickOrTap || isUnknownGesture) {\n                return;\n            }\n            let composedPath = event.composedPath();\n            composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement));\n            const prevent = this.options.prevent;\n            if (!!composedPath.find((node)=>node instanceof HTMLElement && (typeof prevent === \"function\" && prevent?.(node) || node.hasAttribute?.(\"data-lenis-prevent\") || isTouch && node.hasAttribute?.(\"data-lenis-prevent-touch\") || isWheel && node.hasAttribute?.(\"data-lenis-prevent-wheel\") || this.options.allowNestedScroll && this.checkNestedScroll(node, {\n                    deltaX,\n                    deltaY\n                })))) return;\n            if (this.isStopped || this.isLocked) {\n                if (event.cancelable) {\n                    event.preventDefault();\n                }\n                return;\n            }\n            const isSmooth = this.options.syncTouch && isTouch || this.options.smoothWheel && isWheel;\n            if (!isSmooth) {\n                this.isScrolling = \"native\";\n                this.animate.stop();\n                event.lenisStopPropagation = true;\n                return;\n            }\n            let delta = deltaY;\n            if (this.options.gestureOrientation === \"both\") {\n                delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX;\n            } else if (this.options.gestureOrientation === \"horizontal\") {\n                delta = deltaX;\n            }\n            if (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && this.limit > 0 && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && deltaY > 0 || this.animatedScroll === this.limit && deltaY < 0)) {\n                event.lenisStopPropagation = true;\n            }\n            if (event.cancelable) {\n                event.preventDefault();\n            }\n            const isSyncTouch = isTouch && this.options.syncTouch;\n            const isTouchEnd = isTouch && event.type === \"touchend\";\n            const hasTouchInertia = isTouchEnd;\n            if (hasTouchInertia) {\n                delta = Math.sign(this.velocity) * Math.pow(Math.abs(this.velocity), this.options.touchInertiaExponent);\n            }\n            this.scrollTo(this.targetScroll + delta, {\n                programmatic: false,\n                ...isSyncTouch ? {\n                    lerp: hasTouchInertia ? this.options.syncTouchLerp : 1\n                } : {\n                    lerp: this.options.lerp,\n                    duration: this.options.duration,\n                    easing: this.options.easing\n                }\n            });\n        };\n        this.onNativeScroll = ()=>{\n            if (this._resetVelocityTimeout !== null) {\n                clearTimeout(this._resetVelocityTimeout);\n                this._resetVelocityTimeout = null;\n            }\n            if (this._preventNextNativeScrollEvent) {\n                this._preventNextNativeScrollEvent = false;\n                return;\n            }\n            if (this.isScrolling === false || this.isScrolling === \"native\") {\n                const lastScroll = this.animatedScroll;\n                this.animatedScroll = this.targetScroll = this.actualScroll;\n                this.lastVelocity = this.velocity;\n                this.velocity = this.animatedScroll - lastScroll;\n                this.direction = Math.sign(this.animatedScroll - lastScroll);\n                if (!this.isStopped) {\n                    this.isScrolling = \"native\";\n                }\n                this.emit();\n                if (this.velocity !== 0) {\n                    this._resetVelocityTimeout = setTimeout(()=>{\n                        this.lastVelocity = this.velocity;\n                        this.velocity = 0;\n                        this.isScrolling = false;\n                        this.emit();\n                    }, 400);\n                }\n            }\n        };\n        /**\n   * RequestAnimationFrame for lenis\n   *\n   * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus\n   */ this.raf = (time)=>{\n            const deltaTime = time - (this.time || time);\n            this.time = time;\n            this.animate.advance(deltaTime * 1e-3);\n            if (this.options.autoRaf) {\n                this._rafId = requestAnimationFrame(this.raf);\n            }\n        };\n        window.lenisVersion = version;\n        if (!wrapper || wrapper === document.documentElement) {\n            wrapper = window;\n        }\n        if (typeof duration === \"number\" && typeof easing !== \"function\") {\n            easing = defaultEasing;\n        } else if (typeof easing === \"function\" && typeof duration !== \"number\") {\n            duration = 1;\n        }\n        this.options = {\n            wrapper,\n            content,\n            eventsTarget,\n            smoothWheel,\n            syncTouch,\n            syncTouchLerp,\n            touchInertiaExponent,\n            duration,\n            easing,\n            lerp: lerp2,\n            infinite,\n            gestureOrientation,\n            orientation,\n            touchMultiplier,\n            wheelMultiplier,\n            autoResize,\n            prevent,\n            virtualScroll,\n            overscroll,\n            autoRaf,\n            anchors,\n            autoToggle,\n            allowNestedScroll,\n            naiveDimensions,\n            stopInertiaOnNavigate\n        };\n        this.dimensions = new Dimensions(wrapper, content, {\n            autoResize\n        });\n        this.updateClassName();\n        this.targetScroll = this.animatedScroll = this.actualScroll;\n        this.options.wrapper.addEventListener(\"scroll\", this.onNativeScroll, false);\n        this.options.wrapper.addEventListener(\"scrollend\", this.onScrollEnd, {\n            capture: true\n        });\n        if (this.options.anchors || this.options.stopInertiaOnNavigate) {\n            this.options.wrapper.addEventListener(\"click\", this.onClick, false);\n        }\n        this.options.wrapper.addEventListener(\"pointerdown\", this.onPointerDown, false);\n        this.virtualScroll = new VirtualScroll(eventsTarget, {\n            touchMultiplier,\n            wheelMultiplier\n        });\n        this.virtualScroll.on(\"scroll\", this.onVirtualScroll);\n        if (this.options.autoToggle) {\n            this.checkOverflow();\n            this.rootElement.addEventListener(\"transitionend\", this.onTransitionEnd, {\n                passive: true\n            });\n        }\n        if (this.options.autoRaf) {\n            this._rafId = requestAnimationFrame(this.raf);\n        }\n    }\n    /**\n   * Destroy the lenis instance, remove all event listeners and clean up the class name\n   */ destroy() {\n        this.emitter.destroy();\n        this.options.wrapper.removeEventListener(\"scroll\", this.onNativeScroll, false);\n        this.options.wrapper.removeEventListener(\"scrollend\", this.onScrollEnd, {\n            capture: true\n        });\n        this.options.wrapper.removeEventListener(\"pointerdown\", this.onPointerDown, false);\n        if (this.options.anchors || this.options.stopInertiaOnNavigate) {\n            this.options.wrapper.removeEventListener(\"click\", this.onClick, false);\n        }\n        this.virtualScroll.destroy();\n        this.dimensions.destroy();\n        this.cleanUpClassName();\n        if (this._rafId) {\n            cancelAnimationFrame(this._rafId);\n        }\n    }\n    on(event, callback) {\n        return this.emitter.on(event, callback);\n    }\n    off(event, callback) {\n        return this.emitter.off(event, callback);\n    }\n    get overflow() {\n        const property = this.isHorizontal ? \"overflow-x\" : \"overflow-y\";\n        return getComputedStyle(this.rootElement)[property];\n    }\n    checkOverflow() {\n        if ([\n            \"hidden\",\n            \"clip\"\n        ].includes(this.overflow)) {\n            this.internalStop();\n        } else {\n            this.internalStart();\n        }\n    }\n    setScroll(scroll) {\n        if (this.isHorizontal) {\n            this.options.wrapper.scrollTo({\n                left: scroll,\n                behavior: \"instant\"\n            });\n        } else {\n            this.options.wrapper.scrollTo({\n                top: scroll,\n                behavior: \"instant\"\n            });\n        }\n    }\n    /**\n   * Force lenis to recalculate the dimensions\n   */ resize() {\n        this.dimensions.resize();\n        this.animatedScroll = this.targetScroll = this.actualScroll;\n        this.emit();\n    }\n    emit() {\n        this.emitter.emit(\"scroll\", this);\n    }\n    reset() {\n        this.isLocked = false;\n        this.isScrolling = false;\n        this.animatedScroll = this.targetScroll = this.actualScroll;\n        this.lastVelocity = this.velocity = 0;\n        this.animate.stop();\n    }\n    /**\n   * Start lenis scroll after it has been stopped\n   */ start() {\n        if (!this.isStopped) return;\n        if (this.options.autoToggle) {\n            this.rootElement.style.removeProperty(\"overflow\");\n            return;\n        }\n        this.internalStart();\n    }\n    internalStart() {\n        if (!this.isStopped) return;\n        this.reset();\n        this.isStopped = false;\n        this.emit();\n    }\n    /**\n   * Stop lenis scroll\n   */ stop() {\n        if (this.isStopped) return;\n        if (this.options.autoToggle) {\n            this.rootElement.style.setProperty(\"overflow\", \"clip\");\n            return;\n        }\n        this.internalStop();\n    }\n    internalStop() {\n        if (this.isStopped) return;\n        this.reset();\n        this.isStopped = true;\n        this.emit();\n    }\n    /**\n   * Scroll to a target value\n   *\n   * @param target The target value to scroll to\n   * @param options The options for the scroll\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   offset: 100,\n   *   duration: 1,\n   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),\n   *   lerp: 0.1,\n   *   onStart: () => {\n   *     console.log('onStart')\n   *   },\n   *   onComplete: () => {\n   *     console.log('onComplete')\n   *   },\n   * })\n   */ scrollTo(target, { offset = 0, immediate = false, lock = false, programmatic = true, // called from outside of the class\n    lerp: lerp2 = programmatic ? this.options.lerp : void 0, duration = programmatic ? this.options.duration : void 0, easing = programmatic ? this.options.easing : void 0, onStart, onComplete, force = false, // scroll even if stopped\n    userData } = {}) {\n        if ((this.isStopped || this.isLocked) && !force) return;\n        if (typeof target === \"string\" && [\n            \"top\",\n            \"left\",\n            \"start\",\n            \"#\"\n        ].includes(target)) {\n            target = 0;\n        } else if (typeof target === \"string\" && [\n            \"bottom\",\n            \"right\",\n            \"end\"\n        ].includes(target)) {\n            target = this.limit;\n        } else {\n            let node;\n            if (typeof target === \"string\") {\n                node = document.querySelector(target);\n                if (!node) {\n                    if (target === \"#top\") {\n                        target = 0;\n                    } else {\n                        console.warn(\"Lenis: Target not found\", target);\n                    }\n                }\n            } else if (target instanceof HTMLElement && target?.nodeType) {\n                node = target;\n            }\n            if (node) {\n                if (this.options.wrapper !== window) {\n                    const wrapperRect = this.rootElement.getBoundingClientRect();\n                    offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top;\n                }\n                const rect = node.getBoundingClientRect();\n                target = (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll;\n            }\n        }\n        if (typeof target !== \"number\") return;\n        target += offset;\n        target = Math.round(target);\n        if (this.options.infinite) {\n            if (programmatic) {\n                this.targetScroll = this.animatedScroll = this.scroll;\n                const distance = target - this.animatedScroll;\n                if (distance > this.limit / 2) {\n                    target = target - this.limit;\n                } else if (distance < -this.limit / 2) {\n                    target = target + this.limit;\n                }\n            }\n        } else {\n            target = clamp(0, target, this.limit);\n        }\n        if (target === this.targetScroll) {\n            onStart?.(this);\n            onComplete?.(this);\n            return;\n        }\n        this.userData = userData ?? {};\n        if (immediate) {\n            this.animatedScroll = this.targetScroll = target;\n            this.setScroll(this.scroll);\n            this.reset();\n            this.preventNextNativeScrollEvent();\n            this.emit();\n            onComplete?.(this);\n            this.userData = {};\n            requestAnimationFrame(()=>{\n                this.dispatchScrollendEvent();\n            });\n            return;\n        }\n        if (!programmatic) {\n            this.targetScroll = target;\n        }\n        if (typeof duration === \"number\" && typeof easing !== \"function\") {\n            easing = defaultEasing;\n        } else if (typeof easing === \"function\" && typeof duration !== \"number\") {\n            duration = 1;\n        }\n        this.animate.fromTo(this.animatedScroll, target, {\n            duration,\n            easing,\n            lerp: lerp2,\n            onStart: ()=>{\n                if (lock) this.isLocked = true;\n                this.isScrolling = \"smooth\";\n                onStart?.(this);\n            },\n            onUpdate: (value, completed)=>{\n                this.isScrolling = \"smooth\";\n                this.lastVelocity = this.velocity;\n                this.velocity = value - this.animatedScroll;\n                this.direction = Math.sign(this.velocity);\n                this.animatedScroll = value;\n                this.setScroll(this.scroll);\n                if (programmatic) {\n                    this.targetScroll = value;\n                }\n                if (!completed) this.emit();\n                if (completed) {\n                    this.reset();\n                    this.emit();\n                    onComplete?.(this);\n                    this.userData = {};\n                    requestAnimationFrame(()=>{\n                        this.dispatchScrollendEvent();\n                    });\n                    this.preventNextNativeScrollEvent();\n                }\n            }\n        });\n    }\n    preventNextNativeScrollEvent() {\n        this._preventNextNativeScrollEvent = true;\n        requestAnimationFrame(()=>{\n            this._preventNextNativeScrollEvent = false;\n        });\n    }\n    checkNestedScroll(node, { deltaX, deltaY }) {\n        const time = Date.now();\n        const cache = node._lenis ??= {};\n        let hasOverflowX, hasOverflowY, isScrollableX, isScrollableY, scrollWidth, scrollHeight, clientWidth, clientHeight;\n        const gestureOrientation = this.options.gestureOrientation;\n        if (time - (cache.time ?? 0) > 2e3) {\n            cache.time = Date.now();\n            const computedStyle = window.getComputedStyle(node);\n            cache.computedStyle = computedStyle;\n            const overflowXString = computedStyle.overflowX;\n            const overflowYString = computedStyle.overflowY;\n            hasOverflowX = [\n                \"auto\",\n                \"overlay\",\n                \"scroll\"\n            ].includes(overflowXString);\n            hasOverflowY = [\n                \"auto\",\n                \"overlay\",\n                \"scroll\"\n            ].includes(overflowYString);\n            cache.hasOverflowX = hasOverflowX;\n            cache.hasOverflowY = hasOverflowY;\n            if (!hasOverflowX && !hasOverflowY) return false;\n            if (gestureOrientation === \"vertical\" && !hasOverflowY) return false;\n            if (gestureOrientation === \"horizontal\" && !hasOverflowX) return false;\n            scrollWidth = node.scrollWidth;\n            scrollHeight = node.scrollHeight;\n            clientWidth = node.clientWidth;\n            clientHeight = node.clientHeight;\n            isScrollableX = scrollWidth > clientWidth;\n            isScrollableY = scrollHeight > clientHeight;\n            cache.isScrollableX = isScrollableX;\n            cache.isScrollableY = isScrollableY;\n            cache.scrollWidth = scrollWidth;\n            cache.scrollHeight = scrollHeight;\n            cache.clientWidth = clientWidth;\n            cache.clientHeight = clientHeight;\n        } else {\n            isScrollableX = cache.isScrollableX;\n            isScrollableY = cache.isScrollableY;\n            hasOverflowX = cache.hasOverflowX;\n            hasOverflowY = cache.hasOverflowY;\n            scrollWidth = cache.scrollWidth;\n            scrollHeight = cache.scrollHeight;\n            clientWidth = cache.clientWidth;\n            clientHeight = cache.clientHeight;\n        }\n        if (!hasOverflowX && !hasOverflowY || !isScrollableX && !isScrollableY) {\n            return false;\n        }\n        if (gestureOrientation === \"vertical\" && (!hasOverflowY || !isScrollableY)) return false;\n        if (gestureOrientation === \"horizontal\" && (!hasOverflowX || !isScrollableX)) return false;\n        let orientation;\n        if (gestureOrientation === \"horizontal\") {\n            orientation = \"x\";\n        } else if (gestureOrientation === \"vertical\") {\n            orientation = \"y\";\n        } else {\n            const isScrollingX = deltaX !== 0;\n            const isScrollingY = deltaY !== 0;\n            if (isScrollingX && hasOverflowX && isScrollableX) {\n                orientation = \"x\";\n            }\n            if (isScrollingY && hasOverflowY && isScrollableY) {\n                orientation = \"y\";\n            }\n        }\n        if (!orientation) return false;\n        let scroll, maxScroll, delta, hasOverflow, isScrollable;\n        if (orientation === \"x\") {\n            scroll = node.scrollLeft;\n            maxScroll = scrollWidth - clientWidth;\n            delta = deltaX;\n            hasOverflow = hasOverflowX;\n            isScrollable = isScrollableX;\n        } else if (orientation === \"y\") {\n            scroll = node.scrollTop;\n            maxScroll = scrollHeight - clientHeight;\n            delta = deltaY;\n            hasOverflow = hasOverflowY;\n            isScrollable = isScrollableY;\n        } else {\n            return false;\n        }\n        const willScroll = delta > 0 ? scroll < maxScroll : scroll > 0;\n        return willScroll && hasOverflow && isScrollable;\n    }\n    /**\n   * The root element on which lenis is instanced\n   */ get rootElement() {\n        return this.options.wrapper === window ? document.documentElement : this.options.wrapper;\n    }\n    /**\n   * The limit which is the maximum scroll value\n   */ get limit() {\n        if (this.options.naiveDimensions) {\n            if (this.isHorizontal) {\n                return this.rootElement.scrollWidth - this.rootElement.clientWidth;\n            } else {\n                return this.rootElement.scrollHeight - this.rootElement.clientHeight;\n            }\n        } else {\n            return this.dimensions.limit[this.isHorizontal ? \"x\" : \"y\"];\n        }\n    }\n    /**\n   * Whether or not the scroll is horizontal\n   */ get isHorizontal() {\n        return this.options.orientation === \"horizontal\";\n    }\n    /**\n   * The actual scroll value\n   */ get actualScroll() {\n        const wrapper = this.options.wrapper;\n        return this.isHorizontal ? wrapper.scrollX ?? wrapper.scrollLeft : wrapper.scrollY ?? wrapper.scrollTop;\n    }\n    /**\n   * The current scroll value\n   */ get scroll() {\n        return this.options.infinite ? modulo(this.animatedScroll, this.limit) : this.animatedScroll;\n    }\n    /**\n   * The progress of the scroll relative to the limit\n   */ get progress() {\n        return this.limit === 0 ? 1 : this.scroll / this.limit;\n    }\n    /**\n   * Current scroll state\n   */ get isScrolling() {\n        return this._isScrolling;\n    }\n    set isScrolling(value) {\n        if (this._isScrolling !== value) {\n            this._isScrolling = value;\n            this.updateClassName();\n        }\n    }\n    /**\n   * Check if lenis is stopped\n   */ get isStopped() {\n        return this._isStopped;\n    }\n    set isStopped(value) {\n        if (this._isStopped !== value) {\n            this._isStopped = value;\n            this.updateClassName();\n        }\n    }\n    /**\n   * Check if lenis is locked\n   */ get isLocked() {\n        return this._isLocked;\n    }\n    set isLocked(value) {\n        if (this._isLocked !== value) {\n            this._isLocked = value;\n            this.updateClassName();\n        }\n    }\n    /**\n   * Check if lenis is smooth scrolling\n   */ get isSmooth() {\n        return this.isScrolling === \"smooth\";\n    }\n    /**\n   * The class name applied to the wrapper element\n   */ get className() {\n        let className = \"lenis\";\n        if (this.options.autoToggle) className += \" lenis-autoToggle\";\n        if (this.isStopped) className += \" lenis-stopped\";\n        if (this.isLocked) className += \" lenis-locked\";\n        if (this.isScrolling) className += \" lenis-scrolling\";\n        if (this.isScrolling === \"smooth\") className += \" lenis-smooth\";\n        return className;\n    }\n    updateClassName() {\n        this.cleanUpClassName();\n        this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim();\n    }\n    cleanUpClassName() {\n        this.rootElement.className = this.rootElement.className.replace(/lenis(-\\w+)?/g, \"\").trim();\n    }\n};\n //# sourceMappingURL=lenis.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNqQixJQUFJLENBQUM2TCxlQUFlO1FBQ3RCO0lBQ0Y7SUFDQTs7R0FFQyxHQUNELElBQUlqQixXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUNuRCxXQUFXLEtBQUs7SUFDOUI7SUFDQTs7R0FFQyxHQUNELElBQUk2SCxZQUFZO1FBQ2QsSUFBSUEsWUFBWTtRQUNoQixJQUFJLElBQUksQ0FBQ3RMLE9BQU8sQ0FBQ3FDLFVBQVUsRUFBRWlKLGFBQWE7UUFDMUMsSUFBSSxJQUFJLENBQUNyRixTQUFTLEVBQUVxRixhQUFhO1FBQ2pDLElBQUksSUFBSSxDQUFDcEYsUUFBUSxFQUFFb0YsYUFBYTtRQUNoQyxJQUFJLElBQUksQ0FBQzdILFdBQVcsRUFBRTZILGFBQWE7UUFDbkMsSUFBSSxJQUFJLENBQUM3SCxXQUFXLEtBQUssVUFBVTZILGFBQWE7UUFDaEQsT0FBT0E7SUFDVDtJQUNBekQsa0JBQWtCO1FBQ2hCLElBQUksQ0FBQ0UsZ0JBQWdCO1FBQ3JCLElBQUksQ0FBQ3pCLFdBQVcsQ0FBQ2dGLFNBQVMsR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDaEYsV0FBVyxDQUFDZ0YsU0FBUyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUNBLFNBQVMsQ0FBQyxDQUFDLENBQUNDLElBQUk7SUFDckY7SUFDQXhELG1CQUFtQjtRQUNqQixJQUFJLENBQUN6QixXQUFXLENBQUNnRixTQUFTLEdBQUcsSUFBSSxDQUFDaEYsV0FBVyxDQUFDZ0YsU0FBUyxDQUFDRSxPQUFPLENBQUMsaUJBQWlCLElBQUlELElBQUk7SUFDM0Y7QUFDRjtBQUdFLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHRjLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvbGVuaXMvZGlzdC9sZW5pcy5tanM/MTI4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBwYWNrYWdlLmpzb25cbnZhciB2ZXJzaW9uID0gXCIxLjMuMTdcIjtcblxuLy8gcGFja2FnZXMvY29yZS9zcmMvbWF0aHMudHNcbmZ1bmN0aW9uIGNsYW1wKG1pbiwgaW5wdXQsIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihpbnB1dCwgbWF4KSk7XG59XG5mdW5jdGlvbiBsZXJwKHgsIHksIHQpIHtcbiAgcmV0dXJuICgxIC0gdCkgKiB4ICsgdCAqIHk7XG59XG5mdW5jdGlvbiBkYW1wKHgsIHksIGxhbWJkYSwgZGVsdGFUaW1lKSB7XG4gIHJldHVybiBsZXJwKHgsIHksIDEgLSBNYXRoLmV4cCgtbGFtYmRhICogZGVsdGFUaW1lKSk7XG59XG5mdW5jdGlvbiBtb2R1bG8obiwgZCkge1xuICByZXR1cm4gKG4gJSBkICsgZCkgJSBkO1xufVxuXG4vLyBwYWNrYWdlcy9jb3JlL3NyYy9hbmltYXRlLnRzXG52YXIgQW5pbWF0ZSA9IGNsYXNzIHtcbiAgaXNSdW5uaW5nID0gZmFsc2U7XG4gIHZhbHVlID0gMDtcbiAgZnJvbSA9IDA7XG4gIHRvID0gMDtcbiAgY3VycmVudFRpbWUgPSAwO1xuICAvLyBUaGVzZSBhcmUgaW5zdGFuY2lhdGVkIGluIHRoZSBmcm9tVG8gbWV0aG9kXG4gIGxlcnA7XG4gIGR1cmF0aW9uO1xuICBlYXNpbmc7XG4gIG9uVXBkYXRlO1xuICAvKipcbiAgICogQWR2YW5jZSB0aGUgYW5pbWF0aW9uIGJ5IHRoZSBnaXZlbiBkZWx0YSB0aW1lXG4gICAqXG4gICAqIEBwYXJhbSBkZWx0YVRpbWUgLSBUaGUgdGltZSBpbiBzZWNvbmRzIHRvIGFkdmFuY2UgdGhlIGFuaW1hdGlvblxuICAgKi9cbiAgYWR2YW5jZShkZWx0YVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSByZXR1cm47XG4gICAgbGV0IGNvbXBsZXRlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmR1cmF0aW9uICYmIHRoaXMuZWFzaW5nKSB7XG4gICAgICB0aGlzLmN1cnJlbnRUaW1lICs9IGRlbHRhVGltZTtcbiAgICAgIGNvbnN0IGxpbmVhclByb2dyZXNzID0gY2xhbXAoMCwgdGhpcy5jdXJyZW50VGltZSAvIHRoaXMuZHVyYXRpb24sIDEpO1xuICAgICAgY29tcGxldGVkID0gbGluZWFyUHJvZ3Jlc3MgPj0gMTtcbiAgICAgIGNvbnN0IGVhc2VkUHJvZ3Jlc3MgPSBjb21wbGV0ZWQgPyAxIDogdGhpcy5lYXNpbmcobGluZWFyUHJvZ3Jlc3MpO1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuZnJvbSArICh0aGlzLnRvIC0gdGhpcy5mcm9tKSAqIGVhc2VkUHJvZ3Jlc3M7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlcnApIHtcbiAgICAgIHRoaXMudmFsdWUgPSBkYW1wKHRoaXMudmFsdWUsIHRoaXMudG8sIHRoaXMubGVycCAqIDYwLCBkZWx0YVRpbWUpO1xuICAgICAgaWYgKE1hdGgucm91bmQodGhpcy52YWx1ZSkgPT09IHRoaXMudG8pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudG87XG4gICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnRvO1xuICAgICAgY29tcGxldGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNvbXBsZXRlZCkge1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfVxuICAgIHRoaXMub25VcGRhdGU/Lih0aGlzLnZhbHVlLCBjb21wbGV0ZWQpO1xuICB9XG4gIC8qKiBTdG9wIHRoZSBhbmltYXRpb24gKi9cbiAgc3RvcCgpIHtcbiAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdXAgdGhlIGFuaW1hdGlvbiBmcm9tIGEgc3RhcnRpbmcgdmFsdWUgdG8gYW4gZW5kaW5nIHZhbHVlXG4gICAqIHdpdGggb3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgbGVycGluZywgZHVyYXRpb24sIGVhc2luZywgYW5kIG9uVXBkYXRlIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIHN0YXJ0aW5nIHZhbHVlXG4gICAqIEBwYXJhbSB0byAtIFRoZSBlbmRpbmcgdmFsdWVcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgYW5pbWF0aW9uXG4gICAqL1xuICBmcm9tVG8oZnJvbSwgdG8sIHsgbGVycDogbGVycDIsIGR1cmF0aW9uLCBlYXNpbmcsIG9uU3RhcnQsIG9uVXBkYXRlIH0pIHtcbiAgICB0aGlzLmZyb20gPSB0aGlzLnZhbHVlID0gZnJvbTtcbiAgICB0aGlzLnRvID0gdG87XG4gICAgdGhpcy5sZXJwID0gbGVycDI7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMuZWFzaW5nID0gZWFzaW5nO1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcbiAgICBvblN0YXJ0Py4oKTtcbiAgICB0aGlzLm9uVXBkYXRlID0gb25VcGRhdGU7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2NvcmUvc3JjL2RlYm91bmNlLnRzXG5mdW5jdGlvbiBkZWJvdW5jZShjYWxsYmFjaywgZGVsYXkpIHtcbiAgbGV0IHRpbWVyO1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGxldCBjb250ZXh0ID0gdGhpcztcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aW1lciA9IHZvaWQgMDtcbiAgICAgIGNhbGxiYWNrLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH0sIGRlbGF5KTtcbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvY29yZS9zcmMvZGltZW5zaW9ucy50c1xudmFyIERpbWVuc2lvbnMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHdyYXBwZXIsIGNvbnRlbnQsIHsgYXV0b1Jlc2l6ZSA9IHRydWUsIGRlYm91bmNlOiBkZWJvdW5jZVZhbHVlID0gMjUwIH0gPSB7fSkge1xuICAgIHRoaXMud3JhcHBlciA9IHdyYXBwZXI7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICBpZiAoYXV0b1Jlc2l6ZSkge1xuICAgICAgdGhpcy5kZWJvdW5jZWRSZXNpemUgPSBkZWJvdW5jZSh0aGlzLnJlc2l6ZSwgZGVib3VuY2VWYWx1ZSk7XG4gICAgICBpZiAodGhpcy53cmFwcGVyIGluc3RhbmNlb2YgV2luZG93KSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuZGVib3VuY2VkUmVzaXplLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndyYXBwZXJSZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcih0aGlzLmRlYm91bmNlZFJlc2l6ZSk7XG4gICAgICAgIHRoaXMud3JhcHBlclJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy53cmFwcGVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGVudFJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKHRoaXMuZGVib3VuY2VkUmVzaXplKTtcbiAgICAgIHRoaXMuY29udGVudFJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5jb250ZW50KTtcbiAgICB9XG4gICAgdGhpcy5yZXNpemUoKTtcbiAgfVxuICB3aWR0aCA9IDA7XG4gIGhlaWdodCA9IDA7XG4gIHNjcm9sbEhlaWdodCA9IDA7XG4gIHNjcm9sbFdpZHRoID0gMDtcbiAgLy8gVGhlc2UgYXJlIGluc3RhbmNpYXRlZCBpbiB0aGUgY29uc3RydWN0b3IgYXMgdGhleSBuZWVkIGluZm9ybWF0aW9uIGZyb20gdGhlIG9wdGlvbnNcbiAgZGVib3VuY2VkUmVzaXplO1xuICB3cmFwcGVyUmVzaXplT2JzZXJ2ZXI7XG4gIGNvbnRlbnRSZXNpemVPYnNlcnZlcjtcbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLndyYXBwZXJSZXNpemVPYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuY29udGVudFJlc2l6ZU9ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gICAgaWYgKHRoaXMud3JhcHBlciA9PT0gd2luZG93ICYmIHRoaXMuZGVib3VuY2VkUmVzaXplKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLmRlYm91bmNlZFJlc2l6ZSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZXNpemUgPSAoKSA9PiB7XG4gICAgdGhpcy5vbldyYXBwZXJSZXNpemUoKTtcbiAgICB0aGlzLm9uQ29udGVudFJlc2l6ZSgpO1xuICB9O1xuICBvbldyYXBwZXJSZXNpemUgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMud3JhcHBlciBpbnN0YW5jZW9mIFdpbmRvdykge1xuICAgICAgdGhpcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLndyYXBwZXIuY2xpZW50V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMud3JhcHBlci5jbGllbnRIZWlnaHQ7XG4gICAgfVxuICB9O1xuICBvbkNvbnRlbnRSZXNpemUgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMud3JhcHBlciBpbnN0YW5jZW9mIFdpbmRvdykge1xuICAgICAgdGhpcy5zY3JvbGxIZWlnaHQgPSB0aGlzLmNvbnRlbnQuc2Nyb2xsSGVpZ2h0O1xuICAgICAgdGhpcy5zY3JvbGxXaWR0aCA9IHRoaXMuY29udGVudC5zY3JvbGxXaWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zY3JvbGxIZWlnaHQgPSB0aGlzLndyYXBwZXIuc2Nyb2xsSGVpZ2h0O1xuICAgICAgdGhpcy5zY3JvbGxXaWR0aCA9IHRoaXMud3JhcHBlci5zY3JvbGxXaWR0aDtcbiAgICB9XG4gIH07XG4gIGdldCBsaW1pdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdGhpcy5zY3JvbGxXaWR0aCAtIHRoaXMud2lkdGgsXG4gICAgICB5OiB0aGlzLnNjcm9sbEhlaWdodCAtIHRoaXMuaGVpZ2h0XG4gICAgfTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvY29yZS9zcmMvZW1pdHRlci50c1xudmFyIEVtaXR0ZXIgPSBjbGFzcyB7XG4gIGV2ZW50cyA9IHt9O1xuICAvKipcbiAgICogRW1pdCBhbiBldmVudCB3aXRoIHRoZSBnaXZlbiBkYXRhXG4gICAqIEBwYXJhbSBldmVudCBFdmVudCBuYW1lXG4gICAqIEBwYXJhbSBhcmdzIERhdGEgdG8gcGFzcyB0byB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICovXG4gIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBsZXQgY2FsbGJhY2tzID0gdGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhbGxiYWNrc1tpXT8uKC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQWRkIGEgY2FsbGJhY2sgdG8gdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBldmVudCBFdmVudCBuYW1lXG4gICAqIEBwYXJhbSBjYiBDYWxsYmFjayBmdW5jdGlvblxuICAgKiBAcmV0dXJucyBVbnN1YnNjcmliZSBmdW5jdGlvblxuICAgKi9cbiAgb24oZXZlbnQsIGNiKSB7XG4gICAgdGhpcy5ldmVudHNbZXZlbnRdPy5wdXNoKGNiKSB8fCAodGhpcy5ldmVudHNbZXZlbnRdID0gW2NiXSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzW2V2ZW50XSA9IHRoaXMuZXZlbnRzW2V2ZW50XT8uZmlsdGVyKChpKSA9PiBjYiAhPT0gaSk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgZXZlbnRcbiAgICogQHBhcmFtIGV2ZW50IEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAqL1xuICBvZmYoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5ldmVudHNbZXZlbnRdID0gdGhpcy5ldmVudHNbZXZlbnRdPy5maWx0ZXIoKGkpID0+IGNhbGxiYWNrICE9PSBpKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBldmVudCBsaXN0ZW5lcnMgYW5kIGNsZWFuIHVwXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZXZlbnRzID0ge307XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2NvcmUvc3JjL3ZpcnR1YWwtc2Nyb2xsLnRzXG52YXIgTElORV9IRUlHSFQgPSAxMDAgLyA2O1xudmFyIGxpc3RlbmVyT3B0aW9ucyA9IHsgcGFzc2l2ZTogZmFsc2UgfTtcbnZhciBWaXJ0dWFsU2Nyb2xsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zID0geyB3aGVlbE11bHRpcGxpZXI6IDEsIHRvdWNoTXVsdGlwbGllcjogMSB9KSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMub25XaW5kb3dSZXNpemUsIGZhbHNlKTtcbiAgICB0aGlzLm9uV2luZG93UmVzaXplKCk7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCB0aGlzLm9uV2hlZWwsIGxpc3RlbmVyT3B0aW9ucyk7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcInRvdWNoc3RhcnRcIixcbiAgICAgIHRoaXMub25Ub3VjaFN0YXJ0LFxuICAgICAgbGlzdGVuZXJPcHRpb25zXG4gICAgKTtcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwidG91Y2htb3ZlXCIsXG4gICAgICB0aGlzLm9uVG91Y2hNb3ZlLFxuICAgICAgbGlzdGVuZXJPcHRpb25zXG4gICAgKTtcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMub25Ub3VjaEVuZCwgbGlzdGVuZXJPcHRpb25zKTtcbiAgfVxuICB0b3VjaFN0YXJ0ID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuICBsYXN0RGVsdGEgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG4gIHdpbmRvdyA9IHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfTtcbiAgZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gIC8qKlxuICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBnaXZlbiBldmVudCBhbmQgY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAqL1xuICBvbihldmVudCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0dGVyLm9uKGV2ZW50LCBjYWxsYmFjayk7XG4gIH1cbiAgLyoqIFJlbW92ZSBhbGwgZXZlbnQgbGlzdGVuZXJzIGFuZCBjbGVhbiB1cCAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZW1pdHRlci5kZXN0cm95KCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5vbldpbmRvd1Jlc2l6ZSwgZmFsc2UpO1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgdGhpcy5vbldoZWVsLCBsaXN0ZW5lck9wdGlvbnMpO1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgXCJ0b3VjaHN0YXJ0XCIsXG4gICAgICB0aGlzLm9uVG91Y2hTdGFydCxcbiAgICAgIGxpc3RlbmVyT3B0aW9uc1xuICAgICk7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICBcInRvdWNobW92ZVwiLFxuICAgICAgdGhpcy5vblRvdWNoTW92ZSxcbiAgICAgIGxpc3RlbmVyT3B0aW9uc1xuICAgICk7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICBcInRvdWNoZW5kXCIsXG4gICAgICB0aGlzLm9uVG91Y2hFbmQsXG4gICAgICBsaXN0ZW5lck9wdGlvbnNcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciAndG91Y2hzdGFydCcgZXZlbnRcbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IFRvdWNoIGV2ZW50XG4gICAqL1xuICBvblRvdWNoU3RhcnQgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGV2ZW50LnRhcmdldFRvdWNoZXMgPyBldmVudC50YXJnZXRUb3VjaGVzWzBdIDogZXZlbnQ7XG4gICAgdGhpcy50b3VjaFN0YXJ0LnggPSBjbGllbnRYO1xuICAgIHRoaXMudG91Y2hTdGFydC55ID0gY2xpZW50WTtcbiAgICB0aGlzLmxhc3REZWx0YSA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgICB0aGlzLmVtaXR0ZXIuZW1pdChcInNjcm9sbFwiLCB7XG4gICAgICBkZWx0YVg6IDAsXG4gICAgICBkZWx0YVk6IDAsXG4gICAgICBldmVudFxuICAgIH0pO1xuICB9O1xuICAvKiogRXZlbnQgaGFuZGxlciBmb3IgJ3RvdWNobW92ZScgZXZlbnQgKi9cbiAgb25Ub3VjaE1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGV2ZW50LnRhcmdldFRvdWNoZXMgPyBldmVudC50YXJnZXRUb3VjaGVzWzBdIDogZXZlbnQ7XG4gICAgY29uc3QgZGVsdGFYID0gLShjbGllbnRYIC0gdGhpcy50b3VjaFN0YXJ0LngpICogdGhpcy5vcHRpb25zLnRvdWNoTXVsdGlwbGllcjtcbiAgICBjb25zdCBkZWx0YVkgPSAtKGNsaWVudFkgLSB0aGlzLnRvdWNoU3RhcnQueSkgKiB0aGlzLm9wdGlvbnMudG91Y2hNdWx0aXBsaWVyO1xuICAgIHRoaXMudG91Y2hTdGFydC54ID0gY2xpZW50WDtcbiAgICB0aGlzLnRvdWNoU3RhcnQueSA9IGNsaWVudFk7XG4gICAgdGhpcy5sYXN0RGVsdGEgPSB7XG4gICAgICB4OiBkZWx0YVgsXG4gICAgICB5OiBkZWx0YVlcbiAgICB9O1xuICAgIHRoaXMuZW1pdHRlci5lbWl0KFwic2Nyb2xsXCIsIHtcbiAgICAgIGRlbHRhWCxcbiAgICAgIGRlbHRhWSxcbiAgICAgIGV2ZW50XG4gICAgfSk7XG4gIH07XG4gIG9uVG91Y2hFbmQgPSAoZXZlbnQpID0+IHtcbiAgICB0aGlzLmVtaXR0ZXIuZW1pdChcInNjcm9sbFwiLCB7XG4gICAgICBkZWx0YVg6IHRoaXMubGFzdERlbHRhLngsXG4gICAgICBkZWx0YVk6IHRoaXMubGFzdERlbHRhLnksXG4gICAgICBldmVudFxuICAgIH0pO1xuICB9O1xuICAvKiogRXZlbnQgaGFuZGxlciBmb3IgJ3doZWVsJyBldmVudCAqL1xuICBvbldoZWVsID0gKGV2ZW50KSA9PiB7XG4gICAgbGV0IHsgZGVsdGFYLCBkZWx0YVksIGRlbHRhTW9kZSB9ID0gZXZlbnQ7XG4gICAgY29uc3QgbXVsdGlwbGllclggPSBkZWx0YU1vZGUgPT09IDEgPyBMSU5FX0hFSUdIVCA6IGRlbHRhTW9kZSA9PT0gMiA/IHRoaXMud2luZG93LndpZHRoIDogMTtcbiAgICBjb25zdCBtdWx0aXBsaWVyWSA9IGRlbHRhTW9kZSA9PT0gMSA/IExJTkVfSEVJR0hUIDogZGVsdGFNb2RlID09PSAyID8gdGhpcy53aW5kb3cuaGVpZ2h0IDogMTtcbiAgICBkZWx0YVggKj0gbXVsdGlwbGllclg7XG4gICAgZGVsdGFZICo9IG11bHRpcGxpZXJZO1xuICAgIGRlbHRhWCAqPSB0aGlzLm9wdGlvbnMud2hlZWxNdWx0aXBsaWVyO1xuICAgIGRlbHRhWSAqPSB0aGlzLm9wdGlvbnMud2hlZWxNdWx0aXBsaWVyO1xuICAgIHRoaXMuZW1pdHRlci5lbWl0KFwic2Nyb2xsXCIsIHsgZGVsdGFYLCBkZWx0YVksIGV2ZW50IH0pO1xuICB9O1xuICBvbldpbmRvd1Jlc2l6ZSA9ICgpID0+IHtcbiAgICB0aGlzLndpbmRvdyA9IHtcbiAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0XG4gICAgfTtcbiAgfTtcbn07XG5cbi8vIHBhY2thZ2VzL2NvcmUvc3JjL2xlbmlzLnRzXG52YXIgZGVmYXVsdEVhc2luZyA9ICh0KSA9PiBNYXRoLm1pbigxLCAxLjAwMSAtIE1hdGgucG93KDIsIC0xMCAqIHQpKTtcbnZhciBMZW5pcyA9IGNsYXNzIHtcbiAgX2lzU2Nyb2xsaW5nID0gZmFsc2U7XG4gIC8vIHRydWUgd2hlbiBzY3JvbGwgaXMgYW5pbWF0aW5nXG4gIF9pc1N0b3BwZWQgPSBmYWxzZTtcbiAgLy8gdHJ1ZSBpZiB1c2VyIHNob3VsZCBub3QgYmUgYWJsZSB0byBzY3JvbGwgLSBlbmFibGUvZGlzYWJsZSBwcm9ncmFtbWF0aWNhbGx5XG4gIF9pc0xvY2tlZCA9IGZhbHNlO1xuICAvLyBzYW1lIGFzIGlzU3RvcHBlZCBidXQgZW5hYmxlZC9kaXNhYmxlZCB3aGVuIHNjcm9sbCByZWFjaGVzIHRhcmdldFxuICBfcHJldmVudE5leHROYXRpdmVTY3JvbGxFdmVudCA9IGZhbHNlO1xuICBfcmVzZXRWZWxvY2l0eVRpbWVvdXQgPSBudWxsO1xuICBfcmFmSWQgPSBudWxsO1xuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdGhlIHVzZXIgaXMgdG91Y2hpbmcgdGhlIHNjcmVlblxuICAgKi9cbiAgaXNUb3VjaGluZztcbiAgLyoqXG4gICAqIFRoZSB0aW1lIGluIG1zIHNpbmNlIHRoZSBsZW5pcyBpbnN0YW5jZSB3YXMgY3JlYXRlZFxuICAgKi9cbiAgdGltZSA9IDA7XG4gIC8qKlxuICAgKiBVc2VyIGRhdGEgdGhhdCB3aWxsIGJlIGZvcndhcmRlZCB0aHJvdWdoIHRoZSBzY3JvbGwgZXZlbnRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbGVuaXMuc2Nyb2xsVG8oMTAwLCB7XG4gICAqICAgdXNlckRhdGE6IHtcbiAgICogICAgIGZvbzogJ2JhcidcbiAgICogICB9XG4gICAqIH0pXG4gICAqL1xuICB1c2VyRGF0YSA9IHt9O1xuICAvKipcbiAgICogVGhlIGxhc3QgdmVsb2NpdHkgb2YgdGhlIHNjcm9sbFxuICAgKi9cbiAgbGFzdFZlbG9jaXR5ID0gMDtcbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHZlbG9jaXR5IG9mIHRoZSBzY3JvbGxcbiAgICovXG4gIHZlbG9jaXR5ID0gMDtcbiAgLyoqXG4gICAqIFRoZSBkaXJlY3Rpb24gb2YgdGhlIHNjcm9sbFxuICAgKi9cbiAgZGlyZWN0aW9uID0gMDtcbiAgLyoqXG4gICAqIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgbGVuaXMgaW5zdGFuY2VcbiAgICovXG4gIG9wdGlvbnM7XG4gIC8qKlxuICAgKiBUaGUgdGFyZ2V0IHNjcm9sbCB2YWx1ZVxuICAgKi9cbiAgdGFyZ2V0U2Nyb2xsO1xuICAvKipcbiAgICogVGhlIGFuaW1hdGVkIHNjcm9sbCB2YWx1ZVxuICAgKi9cbiAgYW5pbWF0ZWRTY3JvbGw7XG4gIC8vIFRoZXNlIGFyZSBpbnN0YW5jaWF0ZWQgaGVyZSBhcyB0aGV5IGRvbid0IG5lZWQgaW5mb3JtYXRpb24gZnJvbSB0aGUgb3B0aW9uc1xuICBhbmltYXRlID0gbmV3IEFuaW1hdGUoKTtcbiAgZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gIC8vIFRoZXNlIGFyZSBpbnN0YW5jaWF0ZWQgaW4gdGhlIGNvbnN0cnVjdG9yIGFzIHRoZXkgbmVlZCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBvcHRpb25zXG4gIGRpbWVuc2lvbnM7XG4gIC8vIFRoaXMgaXMgbm90IHByaXZhdGUgYmVjYXVzZSBpdCdzIHVzZWQgaW4gdGhlIFNuYXAgY2xhc3NcbiAgdmlydHVhbFNjcm9sbDtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHdyYXBwZXIgPSB3aW5kb3csXG4gICAgY29udGVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICBldmVudHNUYXJnZXQgPSB3cmFwcGVyLFxuICAgIHNtb290aFdoZWVsID0gdHJ1ZSxcbiAgICBzeW5jVG91Y2ggPSBmYWxzZSxcbiAgICBzeW5jVG91Y2hMZXJwID0gMC4wNzUsXG4gICAgdG91Y2hJbmVydGlhRXhwb25lbnQgPSAxLjcsXG4gICAgZHVyYXRpb24sXG4gICAgLy8gaW4gc2Vjb25kc1xuICAgIGVhc2luZyxcbiAgICBsZXJwOiBsZXJwMiA9IDAuMSxcbiAgICBpbmZpbml0ZSA9IGZhbHNlLFxuICAgIG9yaWVudGF0aW9uID0gXCJ2ZXJ0aWNhbFwiLFxuICAgIC8vIHZlcnRpY2FsLCBob3Jpem9udGFsXG4gICAgZ2VzdHVyZU9yaWVudGF0aW9uID0gb3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gXCJib3RoXCIgOiBcInZlcnRpY2FsXCIsXG4gICAgLy8gdmVydGljYWwsIGhvcml6b250YWwsIGJvdGhcbiAgICB0b3VjaE11bHRpcGxpZXIgPSAxLFxuICAgIHdoZWVsTXVsdGlwbGllciA9IDEsXG4gICAgYXV0b1Jlc2l6ZSA9IHRydWUsXG4gICAgcHJldmVudCxcbiAgICB2aXJ0dWFsU2Nyb2xsLFxuICAgIG92ZXJzY3JvbGwgPSB0cnVlLFxuICAgIGF1dG9SYWYgPSBmYWxzZSxcbiAgICBhbmNob3JzID0gZmFsc2UsXG4gICAgYXV0b1RvZ2dsZSA9IGZhbHNlLFxuICAgIC8vIGh0dHBzOi8vY2FuaXVzZS5jb20vP3NlYXJjaD10cmFuc2l0aW9uLWJlaGF2aW9yXG4gICAgYWxsb3dOZXN0ZWRTY3JvbGwgPSBmYWxzZSxcbiAgICAvLyBAdHMtaWdub3JlOiB0aGlzIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgZnV0dXJlXG4gICAgX19leHBlcmltZW50YWxfX25haXZlRGltZW5zaW9ucyA9IGZhbHNlLFxuICAgIG5haXZlRGltZW5zaW9ucyA9IF9fZXhwZXJpbWVudGFsX19uYWl2ZURpbWVuc2lvbnMsXG4gICAgc3RvcEluZXJ0aWFPbk5hdmlnYXRlID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgd2luZG93LmxlbmlzVmVyc2lvbiA9IHZlcnNpb247XG4gICAgaWYgKCF3cmFwcGVyIHx8IHdyYXBwZXIgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgd3JhcHBlciA9IHdpbmRvdztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgZWFzaW5nICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGVhc2luZyA9IGRlZmF1bHRFYXNpbmc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWFzaW5nID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGR1cmF0aW9uICE9PSBcIm51bWJlclwiKSB7XG4gICAgICBkdXJhdGlvbiA9IDE7XG4gICAgfVxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIHdyYXBwZXIsXG4gICAgICBjb250ZW50LFxuICAgICAgZXZlbnRzVGFyZ2V0LFxuICAgICAgc21vb3RoV2hlZWwsXG4gICAgICBzeW5jVG91Y2gsXG4gICAgICBzeW5jVG91Y2hMZXJwLFxuICAgICAgdG91Y2hJbmVydGlhRXhwb25lbnQsXG4gICAgICBkdXJhdGlvbixcbiAgICAgIGVhc2luZyxcbiAgICAgIGxlcnA6IGxlcnAyLFxuICAgICAgaW5maW5pdGUsXG4gICAgICBnZXN0dXJlT3JpZW50YXRpb24sXG4gICAgICBvcmllbnRhdGlvbixcbiAgICAgIHRvdWNoTXVsdGlwbGllcixcbiAgICAgIHdoZWVsTXVsdGlwbGllcixcbiAgICAgIGF1dG9SZXNpemUsXG4gICAgICBwcmV2ZW50LFxuICAgICAgdmlydHVhbFNjcm9sbCxcbiAgICAgIG92ZXJzY3JvbGwsXG4gICAgICBhdXRvUmFmLFxuICAgICAgYW5jaG9ycyxcbiAgICAgIGF1dG9Ub2dnbGUsXG4gICAgICBhbGxvd05lc3RlZFNjcm9sbCxcbiAgICAgIG5haXZlRGltZW5zaW9ucyxcbiAgICAgIHN0b3BJbmVydGlhT25OYXZpZ2F0ZVxuICAgIH07XG4gICAgdGhpcy5kaW1lbnNpb25zID0gbmV3IERpbWVuc2lvbnMod3JhcHBlciwgY29udGVudCwgeyBhdXRvUmVzaXplIH0pO1xuICAgIHRoaXMudXBkYXRlQ2xhc3NOYW1lKCk7XG4gICAgdGhpcy50YXJnZXRTY3JvbGwgPSB0aGlzLmFuaW1hdGVkU2Nyb2xsID0gdGhpcy5hY3R1YWxTY3JvbGw7XG4gICAgdGhpcy5vcHRpb25zLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uTmF0aXZlU2Nyb2xsLCBmYWxzZSk7XG4gICAgdGhpcy5vcHRpb25zLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbGVuZFwiLCB0aGlzLm9uU2Nyb2xsRW5kLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hbmNob3JzIHx8IHRoaXMub3B0aW9ucy5zdG9wSW5lcnRpYU9uTmF2aWdhdGUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiY2xpY2tcIixcbiAgICAgICAgdGhpcy5vbkNsaWNrLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwicG9pbnRlcmRvd25cIixcbiAgICAgIHRoaXMub25Qb2ludGVyRG93bixcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICB0aGlzLnZpcnR1YWxTY3JvbGwgPSBuZXcgVmlydHVhbFNjcm9sbChldmVudHNUYXJnZXQsIHtcbiAgICAgIHRvdWNoTXVsdGlwbGllcixcbiAgICAgIHdoZWVsTXVsdGlwbGllclxuICAgIH0pO1xuICAgIHRoaXMudmlydHVhbFNjcm9sbC5vbihcInNjcm9sbFwiLCB0aGlzLm9uVmlydHVhbFNjcm9sbCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvVG9nZ2xlKSB7XG4gICAgICB0aGlzLmNoZWNrT3ZlcmZsb3coKTtcbiAgICAgIHRoaXMucm9vdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgdGhpcy5vblRyYW5zaXRpb25FbmQsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1JhZikge1xuICAgICAgdGhpcy5fcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5yYWYpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVzdHJveSB0aGUgbGVuaXMgaW5zdGFuY2UsIHJlbW92ZSBhbGwgZXZlbnQgbGlzdGVuZXJzIGFuZCBjbGVhbiB1cCB0aGUgY2xhc3MgbmFtZVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmVtaXR0ZXIuZGVzdHJveSgpO1xuICAgIHRoaXMub3B0aW9ucy53cmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICBcInNjcm9sbFwiLFxuICAgICAgdGhpcy5vbk5hdGl2ZVNjcm9sbCxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICB0aGlzLm9wdGlvbnMud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsZW5kXCIsIHRoaXMub25TY3JvbGxFbmQsIHtcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLm9wdGlvbnMud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgXCJwb2ludGVyZG93blwiLFxuICAgICAgdGhpcy5vblBvaW50ZXJEb3duLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYW5jaG9ycyB8fCB0aGlzLm9wdGlvbnMuc3RvcEluZXJ0aWFPbk5hdmlnYXRlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICBcImNsaWNrXCIsXG4gICAgICAgIHRoaXMub25DbGljayxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMudmlydHVhbFNjcm9sbC5kZXN0cm95KCk7XG4gICAgdGhpcy5kaW1lbnNpb25zLmRlc3Ryb3koKTtcbiAgICB0aGlzLmNsZWFuVXBDbGFzc05hbWUoKTtcbiAgICBpZiAodGhpcy5fcmFmSWQpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JhZklkKTtcbiAgICB9XG4gIH1cbiAgb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdHRlci5vbihldmVudCwgY2FsbGJhY2spO1xuICB9XG4gIG9mZihldmVudCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0dGVyLm9mZihldmVudCwgY2FsbGJhY2spO1xuICB9XG4gIG9uU2Nyb2xsRW5kID0gKGUpID0+IHtcbiAgICBpZiAoIShlIGluc3RhbmNlb2YgQ3VzdG9tRXZlbnQpKSB7XG4gICAgICBpZiAodGhpcy5pc1Njcm9sbGluZyA9PT0gXCJzbW9vdGhcIiB8fCB0aGlzLmlzU2Nyb2xsaW5nID09PSBmYWxzZSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZGlzcGF0Y2hTY3JvbGxlbmRFdmVudCA9ICgpID0+IHtcbiAgICB0aGlzLm9wdGlvbnMud3JhcHBlci5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IEN1c3RvbUV2ZW50KFwic2Nyb2xsZW5kXCIsIHtcbiAgICAgICAgYnViYmxlczogdGhpcy5vcHRpb25zLndyYXBwZXIgPT09IHdpbmRvdyxcbiAgICAgICAgLy8gY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICAgIGRldGFpbDoge1xuICAgICAgICAgIGxlbmlzU2Nyb2xsRW5kOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfTtcbiAgZ2V0IG92ZXJmbG93KCkge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gdGhpcy5pc0hvcml6b250YWwgPyBcIm92ZXJmbG93LXhcIiA6IFwib3ZlcmZsb3cteVwiO1xuICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKHRoaXMucm9vdEVsZW1lbnQpW3Byb3BlcnR5XTtcbiAgfVxuICBjaGVja092ZXJmbG93KCkge1xuICAgIGlmIChbXCJoaWRkZW5cIiwgXCJjbGlwXCJdLmluY2x1ZGVzKHRoaXMub3ZlcmZsb3cpKSB7XG4gICAgICB0aGlzLmludGVybmFsU3RvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmludGVybmFsU3RhcnQoKTtcbiAgICB9XG4gIH1cbiAgb25UcmFuc2l0aW9uRW5kID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LnByb3BlcnR5TmFtZS5pbmNsdWRlcyhcIm92ZXJmbG93XCIpKSB7XG4gICAgICB0aGlzLmNoZWNrT3ZlcmZsb3coKTtcbiAgICB9XG4gIH07XG4gIHNldFNjcm9sbChzY3JvbGwpIHtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwpIHtcbiAgICAgIHRoaXMub3B0aW9ucy53cmFwcGVyLnNjcm9sbFRvKHsgbGVmdDogc2Nyb2xsLCBiZWhhdmlvcjogXCJpbnN0YW50XCIgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3B0aW9ucy53cmFwcGVyLnNjcm9sbFRvKHsgdG9wOiBzY3JvbGwsIGJlaGF2aW9yOiBcImluc3RhbnRcIiB9KTtcbiAgICB9XG4gIH1cbiAgb25DbGljayA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IHBhdGggPSBldmVudC5jb21wb3NlZFBhdGgoKTtcbiAgICBjb25zdCBhbmNob3JFbGVtZW50cyA9IHBhdGguZmlsdGVyKFxuICAgICAgKG5vZGUpID0+IG5vZGUgaW5zdGFuY2VvZiBIVE1MQW5jaG9yRWxlbWVudCAmJiBub2RlLmdldEF0dHJpYnV0ZShcImhyZWZcIilcbiAgICApO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYW5jaG9ycykge1xuICAgICAgY29uc3QgYW5jaG9yID0gYW5jaG9yRWxlbWVudHMuZmluZChcbiAgICAgICAgKG5vZGUpID0+IG5vZGUuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKT8uaW5jbHVkZXMoXCIjXCIpXG4gICAgICApO1xuICAgICAgaWYgKGFuY2hvcikge1xuICAgICAgICBjb25zdCBocmVmID0gYW5jaG9yLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgICAgIGlmIChocmVmKSB7XG4gICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuYW5jaG9ycyA9PT0gXCJvYmplY3RcIiAmJiB0aGlzLm9wdGlvbnMuYW5jaG9ycyA/IHRoaXMub3B0aW9ucy5hbmNob3JzIDogdm9pZCAwO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGAjJHtocmVmLnNwbGl0KFwiI1wiKVsxXX1gO1xuICAgICAgICAgIHRoaXMuc2Nyb2xsVG8odGFyZ2V0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnN0b3BJbmVydGlhT25OYXZpZ2F0ZSkge1xuICAgICAgY29uc3QgaW50ZXJuYWxMaW5rID0gYW5jaG9yRWxlbWVudHMuZmluZChcbiAgICAgICAgKG5vZGUpID0+IG5vZGUuaG9zdCA9PT0gd2luZG93LmxvY2F0aW9uLmhvc3RcbiAgICAgICk7XG4gICAgICBpZiAoaW50ZXJuYWxMaW5rKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIG9uUG9pbnRlckRvd24gPSAoZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQuYnV0dG9uID09PSAxKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuICB9O1xuICBvblZpcnR1YWxTY3JvbGwgPSAoZGF0YSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnZpcnR1YWxTY3JvbGwgPT09IFwiZnVuY3Rpb25cIiAmJiB0aGlzLm9wdGlvbnMudmlydHVhbFNjcm9sbChkYXRhKSA9PT0gZmFsc2UpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBkZWx0YVgsIGRlbHRhWSwgZXZlbnQgfSA9IGRhdGE7XG4gICAgdGhpcy5lbWl0dGVyLmVtaXQoXCJ2aXJ0dWFsLXNjcm9sbFwiLCB7IGRlbHRhWCwgZGVsdGFZLCBldmVudCB9KTtcbiAgICBpZiAoZXZlbnQuY3RybEtleSkgcmV0dXJuO1xuICAgIGlmIChldmVudC5sZW5pc1N0b3BQcm9wYWdhdGlvbikgcmV0dXJuO1xuICAgIGNvbnN0IGlzVG91Y2ggPSBldmVudC50eXBlLmluY2x1ZGVzKFwidG91Y2hcIik7XG4gICAgY29uc3QgaXNXaGVlbCA9IGV2ZW50LnR5cGUuaW5jbHVkZXMoXCJ3aGVlbFwiKTtcbiAgICB0aGlzLmlzVG91Y2hpbmcgPSBldmVudC50eXBlID09PSBcInRvdWNoc3RhcnRcIiB8fCBldmVudC50eXBlID09PSBcInRvdWNobW92ZVwiO1xuICAgIGNvbnN0IGlzQ2xpY2tPclRhcCA9IGRlbHRhWCA9PT0gMCAmJiBkZWx0YVkgPT09IDA7XG4gICAgY29uc3QgaXNUYXBUb1N0b3AgPSB0aGlzLm9wdGlvbnMuc3luY1RvdWNoICYmIGlzVG91Y2ggJiYgZXZlbnQudHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIgJiYgaXNDbGlja09yVGFwICYmICF0aGlzLmlzU3RvcHBlZCAmJiAhdGhpcy5pc0xvY2tlZDtcbiAgICBpZiAoaXNUYXBUb1N0b3ApIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNVbmtub3duR2VzdHVyZSA9IHRoaXMub3B0aW9ucy5nZXN0dXJlT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiAmJiBkZWx0YVkgPT09IDAgfHwgdGhpcy5vcHRpb25zLmdlc3R1cmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgJiYgZGVsdGFYID09PSAwO1xuICAgIGlmIChpc0NsaWNrT3JUYXAgfHwgaXNVbmtub3duR2VzdHVyZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY29tcG9zZWRQYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgY29tcG9zZWRQYXRoID0gY29tcG9zZWRQYXRoLnNsaWNlKDAsIGNvbXBvc2VkUGF0aC5pbmRleE9mKHRoaXMucm9vdEVsZW1lbnQpKTtcbiAgICBjb25zdCBwcmV2ZW50ID0gdGhpcy5vcHRpb25zLnByZXZlbnQ7XG4gICAgaWYgKCEhY29tcG9zZWRQYXRoLmZpbmQoXG4gICAgICAobm9kZSkgPT4gbm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmICh0eXBlb2YgcHJldmVudCA9PT0gXCJmdW5jdGlvblwiICYmIHByZXZlbnQ/Lihub2RlKSB8fCBub2RlLmhhc0F0dHJpYnV0ZT8uKFwiZGF0YS1sZW5pcy1wcmV2ZW50XCIpIHx8IGlzVG91Y2ggJiYgbm9kZS5oYXNBdHRyaWJ1dGU/LihcImRhdGEtbGVuaXMtcHJldmVudC10b3VjaFwiKSB8fCBpc1doZWVsICYmIG5vZGUuaGFzQXR0cmlidXRlPy4oXCJkYXRhLWxlbmlzLXByZXZlbnQtd2hlZWxcIikgfHwgdGhpcy5vcHRpb25zLmFsbG93TmVzdGVkU2Nyb2xsICYmIHRoaXMuY2hlY2tOZXN0ZWRTY3JvbGwobm9kZSwgeyBkZWx0YVgsIGRlbHRhWSB9KSlcbiAgICApKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0aGlzLmlzU3RvcHBlZCB8fCB0aGlzLmlzTG9ja2VkKSB7XG4gICAgICBpZiAoZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc1Ntb290aCA9IHRoaXMub3B0aW9ucy5zeW5jVG91Y2ggJiYgaXNUb3VjaCB8fCB0aGlzLm9wdGlvbnMuc21vb3RoV2hlZWwgJiYgaXNXaGVlbDtcbiAgICBpZiAoIWlzU21vb3RoKSB7XG4gICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gXCJuYXRpdmVcIjtcbiAgICAgIHRoaXMuYW5pbWF0ZS5zdG9wKCk7XG4gICAgICBldmVudC5sZW5pc1N0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBkZWx0YSA9IGRlbHRhWTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmdlc3R1cmVPcmllbnRhdGlvbiA9PT0gXCJib3RoXCIpIHtcbiAgICAgIGRlbHRhID0gTWF0aC5hYnMoZGVsdGFZKSA+IE1hdGguYWJzKGRlbHRhWCkgPyBkZWx0YVkgOiBkZWx0YVg7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZ2VzdHVyZU9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgZGVsdGEgPSBkZWx0YVg7XG4gICAgfVxuICAgIGlmICghdGhpcy5vcHRpb25zLm92ZXJzY3JvbGwgfHwgdGhpcy5vcHRpb25zLmluZmluaXRlIHx8IHRoaXMub3B0aW9ucy53cmFwcGVyICE9PSB3aW5kb3cgJiYgdGhpcy5saW1pdCA+IDAgJiYgKHRoaXMuYW5pbWF0ZWRTY3JvbGwgPiAwICYmIHRoaXMuYW5pbWF0ZWRTY3JvbGwgPCB0aGlzLmxpbWl0IHx8IHRoaXMuYW5pbWF0ZWRTY3JvbGwgPT09IDAgJiYgZGVsdGFZID4gMCB8fCB0aGlzLmFuaW1hdGVkU2Nyb2xsID09PSB0aGlzLmxpbWl0ICYmIGRlbHRhWSA8IDApKSB7XG4gICAgICBldmVudC5sZW5pc1N0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgfVxuICAgIGlmIChldmVudC5jYW5jZWxhYmxlKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBjb25zdCBpc1N5bmNUb3VjaCA9IGlzVG91Y2ggJiYgdGhpcy5vcHRpb25zLnN5bmNUb3VjaDtcbiAgICBjb25zdCBpc1RvdWNoRW5kID0gaXNUb3VjaCAmJiBldmVudC50eXBlID09PSBcInRvdWNoZW5kXCI7XG4gICAgY29uc3QgaGFzVG91Y2hJbmVydGlhID0gaXNUb3VjaEVuZDtcbiAgICBpZiAoaGFzVG91Y2hJbmVydGlhKSB7XG4gICAgICBkZWx0YSA9IE1hdGguc2lnbih0aGlzLnZlbG9jaXR5KSAqIE1hdGgucG93KE1hdGguYWJzKHRoaXMudmVsb2NpdHkpLCB0aGlzLm9wdGlvbnMudG91Y2hJbmVydGlhRXhwb25lbnQpO1xuICAgIH1cbiAgICB0aGlzLnNjcm9sbFRvKHRoaXMudGFyZ2V0U2Nyb2xsICsgZGVsdGEsIHtcbiAgICAgIHByb2dyYW1tYXRpYzogZmFsc2UsXG4gICAgICAuLi5pc1N5bmNUb3VjaCA/IHtcbiAgICAgICAgbGVycDogaGFzVG91Y2hJbmVydGlhID8gdGhpcy5vcHRpb25zLnN5bmNUb3VjaExlcnAgOiAxXG4gICAgICB9IDoge1xuICAgICAgICBsZXJwOiB0aGlzLm9wdGlvbnMubGVycCxcbiAgICAgICAgZHVyYXRpb246IHRoaXMub3B0aW9ucy5kdXJhdGlvbixcbiAgICAgICAgZWFzaW5nOiB0aGlzLm9wdGlvbnMuZWFzaW5nXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBGb3JjZSBsZW5pcyB0byByZWNhbGN1bGF0ZSB0aGUgZGltZW5zaW9uc1xuICAgKi9cbiAgcmVzaXplKCkge1xuICAgIHRoaXMuZGltZW5zaW9ucy5yZXNpemUoKTtcbiAgICB0aGlzLmFuaW1hdGVkU2Nyb2xsID0gdGhpcy50YXJnZXRTY3JvbGwgPSB0aGlzLmFjdHVhbFNjcm9sbDtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICBlbWl0KCkge1xuICAgIHRoaXMuZW1pdHRlci5lbWl0KFwic2Nyb2xsXCIsIHRoaXMpO1xuICB9XG4gIG9uTmF0aXZlU2Nyb2xsID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLl9yZXNldFZlbG9jaXR5VGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3Jlc2V0VmVsb2NpdHlUaW1lb3V0KTtcbiAgICAgIHRoaXMuX3Jlc2V0VmVsb2NpdHlUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3ByZXZlbnROZXh0TmF0aXZlU2Nyb2xsRXZlbnQpIHtcbiAgICAgIHRoaXMuX3ByZXZlbnROZXh0TmF0aXZlU2Nyb2xsRXZlbnQgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTY3JvbGxpbmcgPT09IGZhbHNlIHx8IHRoaXMuaXNTY3JvbGxpbmcgPT09IFwibmF0aXZlXCIpIHtcbiAgICAgIGNvbnN0IGxhc3RTY3JvbGwgPSB0aGlzLmFuaW1hdGVkU2Nyb2xsO1xuICAgICAgdGhpcy5hbmltYXRlZFNjcm9sbCA9IHRoaXMudGFyZ2V0U2Nyb2xsID0gdGhpcy5hY3R1YWxTY3JvbGw7XG4gICAgICB0aGlzLmxhc3RWZWxvY2l0eSA9IHRoaXMudmVsb2NpdHk7XG4gICAgICB0aGlzLnZlbG9jaXR5ID0gdGhpcy5hbmltYXRlZFNjcm9sbCAtIGxhc3RTY3JvbGw7XG4gICAgICB0aGlzLmRpcmVjdGlvbiA9IE1hdGguc2lnbihcbiAgICAgICAgdGhpcy5hbmltYXRlZFNjcm9sbCAtIGxhc3RTY3JvbGxcbiAgICAgICk7XG4gICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSBcIm5hdGl2ZVwiO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KCk7XG4gICAgICBpZiAodGhpcy52ZWxvY2l0eSAhPT0gMCkge1xuICAgICAgICB0aGlzLl9yZXNldFZlbG9jaXR5VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMubGFzdFZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eTtcbiAgICAgICAgICB0aGlzLnZlbG9jaXR5ID0gMDtcbiAgICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5lbWl0KCk7XG4gICAgICAgIH0sIDQwMCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXNldCgpIHtcbiAgICB0aGlzLmlzTG9ja2VkID0gZmFsc2U7XG4gICAgdGhpcy5pc1Njcm9sbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuYW5pbWF0ZWRTY3JvbGwgPSB0aGlzLnRhcmdldFNjcm9sbCA9IHRoaXMuYWN0dWFsU2Nyb2xsO1xuICAgIHRoaXMubGFzdFZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eSA9IDA7XG4gICAgdGhpcy5hbmltYXRlLnN0b3AoKTtcbiAgfVxuICAvKipcbiAgICogU3RhcnQgbGVuaXMgc2Nyb2xsIGFmdGVyIGl0IGhhcyBiZWVuIHN0b3BwZWRcbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHJldHVybjtcbiAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9Ub2dnbGUpIHtcbiAgICAgIHRoaXMucm9vdEVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJvdmVyZmxvd1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pbnRlcm5hbFN0YXJ0KCk7XG4gIH1cbiAgaW50ZXJuYWxTdGFydCgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSByZXR1cm47XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3AgbGVuaXMgc2Nyb2xsXG4gICAqL1xuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLmlzU3RvcHBlZCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1RvZ2dsZSkge1xuICAgICAgdGhpcy5yb290RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIm92ZXJmbG93XCIsIFwiY2xpcFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pbnRlcm5hbFN0b3AoKTtcbiAgfVxuICBpbnRlcm5hbFN0b3AoKSB7XG4gICAgaWYgKHRoaXMuaXNTdG9wcGVkKSByZXR1cm47XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdEFuaW1hdGlvbkZyYW1lIGZvciBsZW5pc1xuICAgKlxuICAgKiBAcGFyYW0gdGltZSBUaGUgdGltZSBpbiBtcyBmcm9tIGFuIGV4dGVybmFsIGNsb2NrIGxpa2UgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgb3IgVGVtcHVzXG4gICAqL1xuICByYWYgPSAodGltZSkgPT4ge1xuICAgIGNvbnN0IGRlbHRhVGltZSA9IHRpbWUgLSAodGhpcy50aW1lIHx8IHRpbWUpO1xuICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgdGhpcy5hbmltYXRlLmFkdmFuY2UoZGVsdGFUaW1lICogMWUtMyk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUmFmKSB7XG4gICAgICB0aGlzLl9yYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJhZik7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogU2Nyb2xsIHRvIGEgdGFyZ2V0IHZhbHVlXG4gICAqXG4gICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCB2YWx1ZSB0byBzY3JvbGwgdG9cbiAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSBzY3JvbGxcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbGVuaXMuc2Nyb2xsVG8oMTAwLCB7XG4gICAqICAgb2Zmc2V0OiAxMDAsXG4gICAqICAgZHVyYXRpb246IDEsXG4gICAqICAgZWFzaW5nOiAodCkgPT4gMSAtIE1hdGguY29zKCh0ICogTWF0aC5QSSkgLyAyKSxcbiAgICogICBsZXJwOiAwLjEsXG4gICAqICAgb25TdGFydDogKCkgPT4ge1xuICAgKiAgICAgY29uc29sZS5sb2coJ29uU3RhcnQnKVxuICAgKiAgIH0sXG4gICAqICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgKiAgICAgY29uc29sZS5sb2coJ29uQ29tcGxldGUnKVxuICAgKiAgIH0sXG4gICAqIH0pXG4gICAqL1xuICBzY3JvbGxUbyh0YXJnZXQsIHtcbiAgICBvZmZzZXQgPSAwLFxuICAgIGltbWVkaWF0ZSA9IGZhbHNlLFxuICAgIGxvY2sgPSBmYWxzZSxcbiAgICBwcm9ncmFtbWF0aWMgPSB0cnVlLFxuICAgIC8vIGNhbGxlZCBmcm9tIG91dHNpZGUgb2YgdGhlIGNsYXNzXG4gICAgbGVycDogbGVycDIgPSBwcm9ncmFtbWF0aWMgPyB0aGlzLm9wdGlvbnMubGVycCA6IHZvaWQgMCxcbiAgICBkdXJhdGlvbiA9IHByb2dyYW1tYXRpYyA/IHRoaXMub3B0aW9ucy5kdXJhdGlvbiA6IHZvaWQgMCxcbiAgICBlYXNpbmcgPSBwcm9ncmFtbWF0aWMgPyB0aGlzLm9wdGlvbnMuZWFzaW5nIDogdm9pZCAwLFxuICAgIG9uU3RhcnQsXG4gICAgb25Db21wbGV0ZSxcbiAgICBmb3JjZSA9IGZhbHNlLFxuICAgIC8vIHNjcm9sbCBldmVuIGlmIHN0b3BwZWRcbiAgICB1c2VyRGF0YVxuICB9ID0ge30pIHtcbiAgICBpZiAoKHRoaXMuaXNTdG9wcGVkIHx8IHRoaXMuaXNMb2NrZWQpICYmICFmb3JjZSkgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcInN0cmluZ1wiICYmIFtcInRvcFwiLCBcImxlZnRcIiwgXCJzdGFydFwiLCBcIiNcIl0uaW5jbHVkZXModGFyZ2V0KSkge1xuICAgICAgdGFyZ2V0ID0gMDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwic3RyaW5nXCIgJiYgW1wiYm90dG9tXCIsIFwicmlnaHRcIiwgXCJlbmRcIl0uaW5jbHVkZXModGFyZ2V0KSkge1xuICAgICAgdGFyZ2V0ID0gdGhpcy5saW1pdDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG5vZGU7XG4gICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBub2RlID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICBpZiAodGFyZ2V0ID09PSBcIiN0b3BcIikge1xuICAgICAgICAgICAgdGFyZ2V0ID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTGVuaXM6IFRhcmdldCBub3QgZm91bmRcIiwgdGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgdGFyZ2V0Py5ub2RlVHlwZSkge1xuICAgICAgICBub2RlID0gdGFyZ2V0O1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy53cmFwcGVyICE9PSB3aW5kb3cpIHtcbiAgICAgICAgICBjb25zdCB3cmFwcGVyUmVjdCA9IHRoaXMucm9vdEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgb2Zmc2V0IC09IHRoaXMuaXNIb3Jpem9udGFsID8gd3JhcHBlclJlY3QubGVmdCA6IHdyYXBwZXJSZWN0LnRvcDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGFyZ2V0ID0gKHRoaXMuaXNIb3Jpem9udGFsID8gcmVjdC5sZWZ0IDogcmVjdC50b3ApICsgdGhpcy5hbmltYXRlZFNjcm9sbDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09IFwibnVtYmVyXCIpIHJldHVybjtcbiAgICB0YXJnZXQgKz0gb2Zmc2V0O1xuICAgIHRhcmdldCA9IE1hdGgucm91bmQodGFyZ2V0KTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmluZmluaXRlKSB7XG4gICAgICBpZiAocHJvZ3JhbW1hdGljKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0U2Nyb2xsID0gdGhpcy5hbmltYXRlZFNjcm9sbCA9IHRoaXMuc2Nyb2xsO1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHRhcmdldCAtIHRoaXMuYW5pbWF0ZWRTY3JvbGw7XG4gICAgICAgIGlmIChkaXN0YW5jZSA+IHRoaXMubGltaXQgLyAyKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0IC0gdGhpcy5saW1pdDtcbiAgICAgICAgfSBlbHNlIGlmIChkaXN0YW5jZSA8IC10aGlzLmxpbWl0IC8gMikge1xuICAgICAgICAgIHRhcmdldCA9IHRhcmdldCArIHRoaXMubGltaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0ID0gY2xhbXAoMCwgdGFyZ2V0LCB0aGlzLmxpbWl0KTtcbiAgICB9XG4gICAgaWYgKHRhcmdldCA9PT0gdGhpcy50YXJnZXRTY3JvbGwpIHtcbiAgICAgIG9uU3RhcnQ/Lih0aGlzKTtcbiAgICAgIG9uQ29tcGxldGU/Lih0aGlzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51c2VyRGF0YSA9IHVzZXJEYXRhID8/IHt9O1xuICAgIGlmIChpbW1lZGlhdGUpIHtcbiAgICAgIHRoaXMuYW5pbWF0ZWRTY3JvbGwgPSB0aGlzLnRhcmdldFNjcm9sbCA9IHRhcmdldDtcbiAgICAgIHRoaXMuc2V0U2Nyb2xsKHRoaXMuc2Nyb2xsKTtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHRoaXMucHJldmVudE5leHROYXRpdmVTY3JvbGxFdmVudCgpO1xuICAgICAgdGhpcy5lbWl0KCk7XG4gICAgICBvbkNvbXBsZXRlPy4odGhpcyk7XG4gICAgICB0aGlzLnVzZXJEYXRhID0ge307XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0aGlzLmRpc3BhdGNoU2Nyb2xsZW5kRXZlbnQoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXByb2dyYW1tYXRpYykge1xuICAgICAgdGhpcy50YXJnZXRTY3JvbGwgPSB0YXJnZXQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZHVyYXRpb24gPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGVhc2luZyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBlYXNpbmcgPSBkZWZhdWx0RWFzaW5nO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVhc2luZyA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkdXJhdGlvbiAhPT0gXCJudW1iZXJcIikge1xuICAgICAgZHVyYXRpb24gPSAxO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGUuZnJvbVRvKHRoaXMuYW5pbWF0ZWRTY3JvbGwsIHRhcmdldCwge1xuICAgICAgZHVyYXRpb24sXG4gICAgICBlYXNpbmcsXG4gICAgICBsZXJwOiBsZXJwMixcbiAgICAgIG9uU3RhcnQ6ICgpID0+IHtcbiAgICAgICAgaWYgKGxvY2spIHRoaXMuaXNMb2NrZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gXCJzbW9vdGhcIjtcbiAgICAgICAgb25TdGFydD8uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIG9uVXBkYXRlOiAodmFsdWUsIGNvbXBsZXRlZCkgPT4ge1xuICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gXCJzbW9vdGhcIjtcbiAgICAgICAgdGhpcy5sYXN0VmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5O1xuICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdmFsdWUgLSB0aGlzLmFuaW1hdGVkU2Nyb2xsO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IE1hdGguc2lnbih0aGlzLnZlbG9jaXR5KTtcbiAgICAgICAgdGhpcy5hbmltYXRlZFNjcm9sbCA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNldFNjcm9sbCh0aGlzLnNjcm9sbCk7XG4gICAgICAgIGlmIChwcm9ncmFtbWF0aWMpIHtcbiAgICAgICAgICB0aGlzLnRhcmdldFNjcm9sbCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29tcGxldGVkKSB0aGlzLmVtaXQoKTtcbiAgICAgICAgaWYgKGNvbXBsZXRlZCkge1xuICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICB0aGlzLmVtaXQoKTtcbiAgICAgICAgICBvbkNvbXBsZXRlPy4odGhpcyk7XG4gICAgICAgICAgdGhpcy51c2VyRGF0YSA9IHt9O1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoU2Nyb2xsZW5kRXZlbnQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnByZXZlbnROZXh0TmF0aXZlU2Nyb2xsRXZlbnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHByZXZlbnROZXh0TmF0aXZlU2Nyb2xsRXZlbnQoKSB7XG4gICAgdGhpcy5fcHJldmVudE5leHROYXRpdmVTY3JvbGxFdmVudCA9IHRydWU7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuX3ByZXZlbnROZXh0TmF0aXZlU2Nyb2xsRXZlbnQgPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxuICBjaGVja05lc3RlZFNjcm9sbChub2RlLCB7IGRlbHRhWCwgZGVsdGFZIH0pIHtcbiAgICBjb25zdCB0aW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBjYWNoZSA9IG5vZGUuX2xlbmlzID8/PSB7fTtcbiAgICBsZXQgaGFzT3ZlcmZsb3dYLCBoYXNPdmVyZmxvd1ksIGlzU2Nyb2xsYWJsZVgsIGlzU2Nyb2xsYWJsZVksIHNjcm9sbFdpZHRoLCBzY3JvbGxIZWlnaHQsIGNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ7XG4gICAgY29uc3QgZ2VzdHVyZU9yaWVudGF0aW9uID0gdGhpcy5vcHRpb25zLmdlc3R1cmVPcmllbnRhdGlvbjtcbiAgICBpZiAodGltZSAtIChjYWNoZS50aW1lID8/IDApID4gMmUzKSB7XG4gICAgICBjYWNoZS50aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgIGNhY2hlLmNvbXB1dGVkU3R5bGUgPSBjb21wdXRlZFN0eWxlO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dYU3RyaW5nID0gY29tcHV0ZWRTdHlsZS5vdmVyZmxvd1g7XG4gICAgICBjb25zdCBvdmVyZmxvd1lTdHJpbmcgPSBjb21wdXRlZFN0eWxlLm92ZXJmbG93WTtcbiAgICAgIGhhc092ZXJmbG93WCA9IFtcImF1dG9cIiwgXCJvdmVybGF5XCIsIFwic2Nyb2xsXCJdLmluY2x1ZGVzKG92ZXJmbG93WFN0cmluZyk7XG4gICAgICBoYXNPdmVyZmxvd1kgPSBbXCJhdXRvXCIsIFwib3ZlcmxheVwiLCBcInNjcm9sbFwiXS5pbmNsdWRlcyhvdmVyZmxvd1lTdHJpbmcpO1xuICAgICAgY2FjaGUuaGFzT3ZlcmZsb3dYID0gaGFzT3ZlcmZsb3dYO1xuICAgICAgY2FjaGUuaGFzT3ZlcmZsb3dZID0gaGFzT3ZlcmZsb3dZO1xuICAgICAgaWYgKCFoYXNPdmVyZmxvd1ggJiYgIWhhc092ZXJmbG93WSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKGdlc3R1cmVPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiICYmICFoYXNPdmVyZmxvd1kpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChnZXN0dXJlT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiICYmICFoYXNPdmVyZmxvd1gpIHJldHVybiBmYWxzZTtcbiAgICAgIHNjcm9sbFdpZHRoID0gbm9kZS5zY3JvbGxXaWR0aDtcbiAgICAgIHNjcm9sbEhlaWdodCA9IG5vZGUuc2Nyb2xsSGVpZ2h0O1xuICAgICAgY2xpZW50V2lkdGggPSBub2RlLmNsaWVudFdpZHRoO1xuICAgICAgY2xpZW50SGVpZ2h0ID0gbm9kZS5jbGllbnRIZWlnaHQ7XG4gICAgICBpc1Njcm9sbGFibGVYID0gc2Nyb2xsV2lkdGggPiBjbGllbnRXaWR0aDtcbiAgICAgIGlzU2Nyb2xsYWJsZVkgPSBzY3JvbGxIZWlnaHQgPiBjbGllbnRIZWlnaHQ7XG4gICAgICBjYWNoZS5pc1Njcm9sbGFibGVYID0gaXNTY3JvbGxhYmxlWDtcbiAgICAgIGNhY2hlLmlzU2Nyb2xsYWJsZVkgPSBpc1Njcm9sbGFibGVZO1xuICAgICAgY2FjaGUuc2Nyb2xsV2lkdGggPSBzY3JvbGxXaWR0aDtcbiAgICAgIGNhY2hlLnNjcm9sbEhlaWdodCA9IHNjcm9sbEhlaWdodDtcbiAgICAgIGNhY2hlLmNsaWVudFdpZHRoID0gY2xpZW50V2lkdGg7XG4gICAgICBjYWNoZS5jbGllbnRIZWlnaHQgPSBjbGllbnRIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzU2Nyb2xsYWJsZVggPSBjYWNoZS5pc1Njcm9sbGFibGVYO1xuICAgICAgaXNTY3JvbGxhYmxlWSA9IGNhY2hlLmlzU2Nyb2xsYWJsZVk7XG4gICAgICBoYXNPdmVyZmxvd1ggPSBjYWNoZS5oYXNPdmVyZmxvd1g7XG4gICAgICBoYXNPdmVyZmxvd1kgPSBjYWNoZS5oYXNPdmVyZmxvd1k7XG4gICAgICBzY3JvbGxXaWR0aCA9IGNhY2hlLnNjcm9sbFdpZHRoO1xuICAgICAgc2Nyb2xsSGVpZ2h0ID0gY2FjaGUuc2Nyb2xsSGVpZ2h0O1xuICAgICAgY2xpZW50V2lkdGggPSBjYWNoZS5jbGllbnRXaWR0aDtcbiAgICAgIGNsaWVudEhlaWdodCA9IGNhY2hlLmNsaWVudEhlaWdodDtcbiAgICB9XG4gICAgaWYgKCFoYXNPdmVyZmxvd1ggJiYgIWhhc092ZXJmbG93WSB8fCAhaXNTY3JvbGxhYmxlWCAmJiAhaXNTY3JvbGxhYmxlWSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZ2VzdHVyZU9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgJiYgKCFoYXNPdmVyZmxvd1kgfHwgIWlzU2Nyb2xsYWJsZVkpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChnZXN0dXJlT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiICYmICghaGFzT3ZlcmZsb3dYIHx8ICFpc1Njcm9sbGFibGVYKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgb3JpZW50YXRpb247XG4gICAgaWYgKGdlc3R1cmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgIG9yaWVudGF0aW9uID0gXCJ4XCI7XG4gICAgfSBlbHNlIGlmIChnZXN0dXJlT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIikge1xuICAgICAgb3JpZW50YXRpb24gPSBcInlcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaXNTY3JvbGxpbmdYID0gZGVsdGFYICE9PSAwO1xuICAgICAgY29uc3QgaXNTY3JvbGxpbmdZID0gZGVsdGFZICE9PSAwO1xuICAgICAgaWYgKGlzU2Nyb2xsaW5nWCAmJiBoYXNPdmVyZmxvd1ggJiYgaXNTY3JvbGxhYmxlWCkge1xuICAgICAgICBvcmllbnRhdGlvbiA9IFwieFwiO1xuICAgICAgfVxuICAgICAgaWYgKGlzU2Nyb2xsaW5nWSAmJiBoYXNPdmVyZmxvd1kgJiYgaXNTY3JvbGxhYmxlWSkge1xuICAgICAgICBvcmllbnRhdGlvbiA9IFwieVwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW9yaWVudGF0aW9uKSByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNjcm9sbCwgbWF4U2Nyb2xsLCBkZWx0YSwgaGFzT3ZlcmZsb3csIGlzU2Nyb2xsYWJsZTtcbiAgICBpZiAob3JpZW50YXRpb24gPT09IFwieFwiKSB7XG4gICAgICBzY3JvbGwgPSBub2RlLnNjcm9sbExlZnQ7XG4gICAgICBtYXhTY3JvbGwgPSBzY3JvbGxXaWR0aCAtIGNsaWVudFdpZHRoO1xuICAgICAgZGVsdGEgPSBkZWx0YVg7XG4gICAgICBoYXNPdmVyZmxvdyA9IGhhc092ZXJmbG93WDtcbiAgICAgIGlzU2Nyb2xsYWJsZSA9IGlzU2Nyb2xsYWJsZVg7XG4gICAgfSBlbHNlIGlmIChvcmllbnRhdGlvbiA9PT0gXCJ5XCIpIHtcbiAgICAgIHNjcm9sbCA9IG5vZGUuc2Nyb2xsVG9wO1xuICAgICAgbWF4U2Nyb2xsID0gc2Nyb2xsSGVpZ2h0IC0gY2xpZW50SGVpZ2h0O1xuICAgICAgZGVsdGEgPSBkZWx0YVk7XG4gICAgICBoYXNPdmVyZmxvdyA9IGhhc092ZXJmbG93WTtcbiAgICAgIGlzU2Nyb2xsYWJsZSA9IGlzU2Nyb2xsYWJsZVk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgd2lsbFNjcm9sbCA9IGRlbHRhID4gMCA/IHNjcm9sbCA8IG1heFNjcm9sbCA6IHNjcm9sbCA+IDA7XG4gICAgcmV0dXJuIHdpbGxTY3JvbGwgJiYgaGFzT3ZlcmZsb3cgJiYgaXNTY3JvbGxhYmxlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcm9vdCBlbGVtZW50IG9uIHdoaWNoIGxlbmlzIGlzIGluc3RhbmNlZFxuICAgKi9cbiAgZ2V0IHJvb3RFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMud3JhcHBlciA9PT0gd2luZG93ID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogdGhpcy5vcHRpb25zLndyYXBwZXI7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBsaW1pdCB3aGljaCBpcyB0aGUgbWF4aW11bSBzY3JvbGwgdmFsdWVcbiAgICovXG4gIGdldCBsaW1pdCgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm5haXZlRGltZW5zaW9ucykge1xuICAgICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RFbGVtZW50LnNjcm9sbFdpZHRoIC0gdGhpcy5yb290RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RFbGVtZW50LnNjcm9sbEhlaWdodCAtIHRoaXMucm9vdEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5kaW1lbnNpb25zLmxpbWl0W3RoaXMuaXNIb3Jpem9udGFsID8gXCJ4XCIgOiBcInlcIl07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgc2Nyb2xsIGlzIGhvcml6b250YWxcbiAgICovXG4gIGdldCBpc0hvcml6b250YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCI7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhY3R1YWwgc2Nyb2xsIHZhbHVlXG4gICAqL1xuICBnZXQgYWN0dWFsU2Nyb2xsKCkge1xuICAgIGNvbnN0IHdyYXBwZXIgPSB0aGlzLm9wdGlvbnMud3JhcHBlcjtcbiAgICByZXR1cm4gdGhpcy5pc0hvcml6b250YWwgPyB3cmFwcGVyLnNjcm9sbFggPz8gd3JhcHBlci5zY3JvbGxMZWZ0IDogd3JhcHBlci5zY3JvbGxZID8/IHdyYXBwZXIuc2Nyb2xsVG9wO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBzY3JvbGwgdmFsdWVcbiAgICovXG4gIGdldCBzY3JvbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pbmZpbml0ZSA/IG1vZHVsbyh0aGlzLmFuaW1hdGVkU2Nyb2xsLCB0aGlzLmxpbWl0KSA6IHRoaXMuYW5pbWF0ZWRTY3JvbGw7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBwcm9ncmVzcyBvZiB0aGUgc2Nyb2xsIHJlbGF0aXZlIHRvIHRoZSBsaW1pdFxuICAgKi9cbiAgZ2V0IHByb2dyZXNzKCkge1xuICAgIHJldHVybiB0aGlzLmxpbWl0ID09PSAwID8gMSA6IHRoaXMuc2Nyb2xsIC8gdGhpcy5saW1pdDtcbiAgfVxuICAvKipcbiAgICogQ3VycmVudCBzY3JvbGwgc3RhdGVcbiAgICovXG4gIGdldCBpc1Njcm9sbGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTY3JvbGxpbmc7XG4gIH1cbiAgc2V0IGlzU2Nyb2xsaW5nKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2lzU2Nyb2xsaW5nICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5faXNTY3JvbGxpbmcgPSB2YWx1ZTtcbiAgICAgIHRoaXMudXBkYXRlQ2xhc3NOYW1lKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBsZW5pcyBpcyBzdG9wcGVkXG4gICAqL1xuICBnZXQgaXNTdG9wcGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0b3BwZWQ7XG4gIH1cbiAgc2V0IGlzU3RvcHBlZCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9pc1N0b3BwZWQgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9pc1N0b3BwZWQgPSB2YWx1ZTtcbiAgICAgIHRoaXMudXBkYXRlQ2xhc3NOYW1lKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBsZW5pcyBpcyBsb2NrZWRcbiAgICovXG4gIGdldCBpc0xvY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNMb2NrZWQ7XG4gIH1cbiAgc2V0IGlzTG9ja2VkKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2lzTG9ja2VkICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5faXNMb2NrZWQgPSB2YWx1ZTtcbiAgICAgIHRoaXMudXBkYXRlQ2xhc3NOYW1lKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBsZW5pcyBpcyBzbW9vdGggc2Nyb2xsaW5nXG4gICAqL1xuICBnZXQgaXNTbW9vdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTY3JvbGxpbmcgPT09IFwic21vb3RoXCI7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjbGFzcyBuYW1lIGFwcGxpZWQgdG8gdGhlIHdyYXBwZXIgZWxlbWVudFxuICAgKi9cbiAgZ2V0IGNsYXNzTmFtZSgpIHtcbiAgICBsZXQgY2xhc3NOYW1lID0gXCJsZW5pc1wiO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1RvZ2dsZSkgY2xhc3NOYW1lICs9IFwiIGxlbmlzLWF1dG9Ub2dnbGVcIjtcbiAgICBpZiAodGhpcy5pc1N0b3BwZWQpIGNsYXNzTmFtZSArPSBcIiBsZW5pcy1zdG9wcGVkXCI7XG4gICAgaWYgKHRoaXMuaXNMb2NrZWQpIGNsYXNzTmFtZSArPSBcIiBsZW5pcy1sb2NrZWRcIjtcbiAgICBpZiAodGhpcy5pc1Njcm9sbGluZykgY2xhc3NOYW1lICs9IFwiIGxlbmlzLXNjcm9sbGluZ1wiO1xuICAgIGlmICh0aGlzLmlzU2Nyb2xsaW5nID09PSBcInNtb290aFwiKSBjbGFzc05hbWUgKz0gXCIgbGVuaXMtc21vb3RoXCI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxuICB1cGRhdGVDbGFzc05hbWUoKSB7XG4gICAgdGhpcy5jbGVhblVwQ2xhc3NOYW1lKCk7XG4gICAgdGhpcy5yb290RWxlbWVudC5jbGFzc05hbWUgPSBgJHt0aGlzLnJvb3RFbGVtZW50LmNsYXNzTmFtZX0gJHt0aGlzLmNsYXNzTmFtZX1gLnRyaW0oKTtcbiAgfVxuICBjbGVhblVwQ2xhc3NOYW1lKCkge1xuICAgIHRoaXMucm9vdEVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5yb290RWxlbWVudC5jbGFzc05hbWUucmVwbGFjZSgvbGVuaXMoLVxcdyspPy9nLCBcIlwiKS50cmltKCk7XG4gIH1cbn07XG5leHBvcnQge1xuICBMZW5pcyBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGVuaXMubWpzLm1hcCJdLCJuYW1lcyI6WyJ2ZXJzaW9uIiwiY2xhbXAiLCJtaW4iLCJpbnB1dCIsIm1heCIsIk1hdGgiLCJsZXJwIiwieCIsInkiLCJ0IiwiZGFtcCIsImxhbWJkYSIsImRlbHRhVGltZSIsImV4cCIsIm1vZHVsbyIsIm4iLCJkIiwiQW5pbWF0ZSIsImFkdmFuY2UiLCJpc1J1bm5pbmciLCJjb21wbGV0ZWQiLCJkdXJhdGlvbiIsImVhc2luZyIsImN1cnJlbnRUaW1lIiwibGluZWFyUHJvZ3Jlc3MiLCJlYXNlZFByb2dyZXNzIiwidmFsdWUiLCJmcm9tIiwidG8iLCJyb3VuZCIsInN0b3AiLCJvblVwZGF0ZSIsImZyb21UbyIsImxlcnAyIiwib25TdGFydCIsImRlYm91bmNlIiwiY2FsbGJhY2siLCJkZWxheSIsInRpbWVyIiwiYXJncyIsImNvbnRleHQiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiYXBwbHkiLCJEaW1lbnNpb25zIiwiY29uc3RydWN0b3IiLCJ3cmFwcGVyIiwiY29udGVudCIsImF1dG9SZXNpemUiLCJkZWJvdW5jZVZhbHVlIiwid2lkdGgiLCJoZWlnaHQiLCJzY3JvbGxIZWlnaHQiLCJzY3JvbGxXaWR0aCIsInJlc2l6ZSIsIm9uV3JhcHBlclJlc2l6ZSIsIm9uQ29udGVudFJlc2l6ZSIsIldpbmRvdyIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiZGVib3VuY2VkUmVzaXplIiwiYWRkRXZlbnRMaXN0ZW5lciIsIndyYXBwZXJSZXNpemVPYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZSIsImNvbnRlbnRSZXNpemVPYnNlcnZlciIsImRlc3Ryb3kiLCJkaXNjb25uZWN0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImxpbWl0IiwiRW1pdHRlciIsImVtaXQiLCJldmVudCIsImNhbGxiYWNrcyIsImV2ZW50cyIsImkiLCJsZW5ndGgiLCJvbiIsImNiIiwicHVzaCIsImZpbHRlciIsIm9mZiIsIkxJTkVfSEVJR0hUIiwibGlzdGVuZXJPcHRpb25zIiwicGFzc2l2ZSIsIlZpcnR1YWxTY3JvbGwiLCJlbGVtZW50Iiwib3B0aW9ucyIsIndoZWVsTXVsdGlwbGllciIsInRvdWNoTXVsdGlwbGllciIsInRvdWNoU3RhcnQiLCJsYXN0RGVsdGEiLCJlbWl0dGVyIiwib25Ub3VjaFN0YXJ0IiwiY2xpZW50WCIsImNsaWVudFkiLCJ0YXJnZXRUb3VjaGVzIiwiZGVsdGFYIiwiZGVsdGFZIiwib25Ub3VjaE1vdmUiLCJvblRvdWNoRW5kIiwib25XaGVlbCIsImRlbHRhTW9kZSIsIm11bHRpcGxpZXJYIiwibXVsdGlwbGllclkiLCJvbldpbmRvd1Jlc2l6ZSIsImRlZmF1bHRFYXNpbmciLCJwb3ciLCJMZW5pcyIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZXZlbnRzVGFyZ2V0Iiwic21vb3RoV2hlZWwiLCJzeW5jVG91Y2giLCJzeW5jVG91Y2hMZXJwIiwidG91Y2hJbmVydGlhRXhwb25lbnQiLCJpbmZpbml0ZSIsIm9yaWVudGF0aW9uIiwiZ2VzdHVyZU9yaWVudGF0aW9uIiwicHJldmVudCIsInZpcnR1YWxTY3JvbGwiLCJvdmVyc2Nyb2xsIiwiYXV0b1JhZiIsImFuY2hvcnMiLCJhdXRvVG9nZ2xlIiwiYWxsb3dOZXN0ZWRTY3JvbGwiLCJfX2V4cGVyaW1lbnRhbF9fbmFpdmVEaW1lbnNpb25zIiwibmFpdmVEaW1lbnNpb25zIiwic3RvcEluZXJ0aWFPbk5hdmlnYXRlIiwiX2lzU2Nyb2xsaW5nIiwiX2lzU3RvcHBlZCIsIl9pc0xvY2tlZCIsIl9wcmV2ZW50TmV4dE5hdGl2ZVNjcm9sbEV2ZW50IiwiX3Jlc2V0VmVsb2NpdHlUaW1lb3V0IiwiX3JhZklkIiwidGltZSIsInVzZXJEYXRhIiwibGFzdFZlbG9jaXR5IiwidmVsb2NpdHkiLCJkaXJlY3Rpb24iLCJhbmltYXRlIiwib25TY3JvbGxFbmQiLCJlIiwiQ3VzdG9tRXZlbnQiLCJpc1Njcm9sbGluZyIsInN0b3BQcm9wYWdhdGlvbiIsImRpc3BhdGNoU2Nyb2xsZW5kRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiYnViYmxlcyIsImRldGFpbCIsImxlbmlzU2Nyb2xsRW5kIiwib25UcmFuc2l0aW9uRW5kIiwicHJvcGVydHlOYW1lIiwiaW5jbHVkZXMiLCJjaGVja092ZXJmbG93Iiwib25DbGljayIsInBhdGgiLCJjb21wb3NlZFBhdGgiLCJhbmNob3JFbGVtZW50cyIsIm5vZGUiLCJIVE1MQW5jaG9yRWxlbWVudCIsImdldEF0dHJpYnV0ZSIsImFuY2hvciIsImZpbmQiLCJocmVmIiwidGFyZ2V0Iiwic3BsaXQiLCJzY3JvbGxUbyIsImludGVybmFsTGluayIsImhvc3QiLCJsb2NhdGlvbiIsInJlc2V0Iiwib25Qb2ludGVyRG93biIsImJ1dHRvbiIsIm9uVmlydHVhbFNjcm9sbCIsImRhdGEiLCJjdHJsS2V5IiwibGVuaXNTdG9wUHJvcGFnYXRpb24iLCJpc1RvdWNoIiwidHlwZSIsImlzV2hlZWwiLCJpc1RvdWNoaW5nIiwiaXNDbGlja09yVGFwIiwiaXNUYXBUb1N0b3AiLCJpc1N0b3BwZWQiLCJpc0xvY2tlZCIsImlzVW5rbm93bkdlc3R1cmUiLCJzbGljZSIsImluZGV4T2YiLCJyb290RWxlbWVudCIsIkhUTUxFbGVtZW50IiwiaGFzQXR0cmlidXRlIiwiY2hlY2tOZXN0ZWRTY3JvbGwiLCJjYW5jZWxhYmxlIiwicHJldmVudERlZmF1bHQiLCJpc1Ntb290aCIsImRlbHRhIiwiYWJzIiwiYW5pbWF0ZWRTY3JvbGwiLCJpc1N5bmNUb3VjaCIsImlzVG91Y2hFbmQiLCJoYXNUb3VjaEluZXJ0aWEiLCJzaWduIiwidGFyZ2V0U2Nyb2xsIiwicHJvZ3JhbW1hdGljIiwib25OYXRpdmVTY3JvbGwiLCJsYXN0U2Nyb2xsIiwiYWN0dWFsU2Nyb2xsIiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibGVuaXNWZXJzaW9uIiwiZGltZW5zaW9ucyIsInVwZGF0ZUNsYXNzTmFtZSIsImNhcHR1cmUiLCJjbGVhblVwQ2xhc3NOYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJvdmVyZmxvdyIsInByb3BlcnR5IiwiaXNIb3Jpem9udGFsIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImludGVybmFsU3RvcCIsImludGVybmFsU3RhcnQiLCJzZXRTY3JvbGwiLCJzY3JvbGwiLCJsZWZ0IiwiYmVoYXZpb3IiLCJ0b3AiLCJzdGFydCIsInN0eWxlIiwicmVtb3ZlUHJvcGVydHkiLCJzZXRQcm9wZXJ0eSIsIm9mZnNldCIsImltbWVkaWF0ZSIsImxvY2siLCJvbkNvbXBsZXRlIiwiZm9yY2UiLCJxdWVyeVNlbGVjdG9yIiwiY29uc29sZSIsIndhcm4iLCJub2RlVHlwZSIsIndyYXBwZXJSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicmVjdCIsImRpc3RhbmNlIiwicHJldmVudE5leHROYXRpdmVTY3JvbGxFdmVudCIsIkRhdGUiLCJub3ciLCJjYWNoZSIsIl9sZW5pcyIsImhhc092ZXJmbG93WCIsImhhc092ZXJmbG93WSIsImlzU2Nyb2xsYWJsZVgiLCJpc1Njcm9sbGFibGVZIiwiY29tcHV0ZWRTdHlsZSIsIm92ZXJmbG93WFN0cmluZyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WVN0cmluZyIsIm92ZXJmbG93WSIsImlzU2Nyb2xsaW5nWCIsImlzU2Nyb2xsaW5nWSIsIm1heFNjcm9sbCIsImhhc092ZXJmbG93IiwiaXNTY3JvbGxhYmxlIiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsIndpbGxTY3JvbGwiLCJzY3JvbGxYIiwic2Nyb2xsWSIsInByb2dyZXNzIiwiY2xhc3NOYW1lIiwidHJpbSIsInJlcGxhY2UiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/lenis/dist/lenis.mjs\n");

/***/ })

};
;